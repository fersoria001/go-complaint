package complaint

import (
	"context"
	"go-complaint/domain"
	"go-complaint/domain/model/common"
	"go-complaint/domain/model/identity"
	"go-complaint/erros"
	"net/mail"
	"slices"
	"strings"
	"time"

	mapset "github.com/deckarep/golang-set/v2"
	"github.com/google/uuid"
)

/*
*
<<Entity>>
<<Value Object>> Status 1
<<Value Object>> Message 1
<<Value Object>> Rating 1
<<Value Object>> ReceiverID 1
Relationships:
- Complaint *..1 Author trough AuthorID
- Complaint *..1 Status
- Complaint *..1 Message
- Complaint *..1 Rating
- Complaint *..1 ReceiverID trough ReceiverID
- Complaint 1..* Reply  trough ID
*/
type Complaint struct {
	id                 uuid.UUID
	authorID           string
	authorFullName     string
	authorProfileIMG   string
	receiverID         string
	receiverFullName   string
	receiverProfileIMG string
	status             Status
	message            Message
	rating             Rating
	createdAt          common.Date
	updatedAt          common.Date
	replies            mapset.Set[*Reply]
}

/*
validated by the requester ID
if its an email then its an user and it must match the author
-users can only close their own complaints-
if its an employee ID then it must match the enterprise
-employees can close sent or received complaints from their enterprise-
*/
func (c *Complaint) SendToHistory(
	ctx context.Context,
	closeRequesterID string,
) error {
	if c.status != CLOSED {
		return &erros.ValidationError{
			Expected: "a complaint must be closed to be sent to history",
		}
	}
	err := c.setStatus(IN_HISTORY)
	if err != nil {
		return err
	}
	domain.DomainEventPublisherInstance().Publish(
		ctx,
		NewComplaintSentToHistory(
			c.id,
			closeRequesterID,
		),
	)
	return nil
}

func (complaintt *Complaint) Rate(
	ctx context.Context,
	triggeredBy string,
	rate int,
	comment string,
) error {
	if complaintt.Status() < IN_REVIEW ||
		complaintt.Status() > CLOSED {
		return &erros.ValidationError{
			Expected: "a complaint must be in review or closed to be rated",
		}
	}
	var (
		err    error
		rating Rating
	)
	rating, err = NewRating(rate, comment)
	if err != nil {
		return err
	}
	complaintt.rating = rating
	err = complaintt.setStatus(CLOSED)
	if err != nil {
		return err
	}
	domain.DomainEventPublisherInstance().Publish(
		ctx,
		NewComplaintClosed(
			complaintt.id,
			complaintt.authorID,
			triggeredBy,
		),
	)
	if _, err = mail.ParseAddress(complaintt.receiverID); err == nil {
		err = complaintt.setStatus(IN_HISTORY)
		if err != nil {
			return err
		}
		domain.DomainEventPublisherInstance().Publish(
			ctx,
			NewComplaintSentToHistory(
				complaintt.id,
				triggeredBy,
			),
		)
	}
	lastReply := complaintt.LastReply()
	domain.DomainEventPublisherInstance().Publish(
		ctx,
		NewComplaintRated(
			complaintt.ID(),
			triggeredBy,
			lastReply.senderID,
			time.Now(),
		),
	)
	return nil
}

/*
If the complaint is already in review status return an error
Set the complaint status to IN_REVIEW
Publish a new event of type WaitingForReview
*/
func (complaint *Complaint) MarkAsReviewable(
	ctx context.Context,
	triggeredBy identity.User,
) error {
	if complaint.status >= IN_REVIEW {
		return &erros.ComplaintClosedError{}
	}
	err := complaint.setStatus(IN_REVIEW)
	if err != nil {
		return err
	}
	commonDate := common.NewDate(time.Now())
	isEnterprise := false
	enterpriseID := ""
	if _, err = mail.ParseAddress(complaint.receiverID); err != nil {
		isEnterprise = true
		enterpriseID = complaint.receiverID
	}
	lastReply, err := NewReply(
		uuid.New(),
		complaint.id,
		triggeredBy.Email(),
		triggeredBy.Email(),
		triggeredBy.FullName(),
		"Marked as reviewable",
		true,
		commonDate,
		commonDate,
		commonDate,
		isEnterprise,
		enterpriseID,
	)
	if err != nil {
		return err
	}
	complaint.replies.Add(lastReply)
	return domain.DomainEventPublisherInstance().Publish(
		ctx,
		NewComplaintSentForReview(
			complaint.id,
			complaint.receiverID,
			complaint.authorID,
			triggeredBy.Email(),
		),
	)
}

/*
It must be generated by application
4 segments
- enterpriseID that match the current enterprise author or receiver
- manager who whire the employee email
- hiring date in 02/01/2006 format
- string random segment of uuid
*/
func (c *Complaint) IsValidEmployeeID(employeeID string) (string, bool) {
	segments := strings.Split(employeeID, "-")
	if len(segments) != 4 {
		return "", false
	}
	if segments[0] != c.authorID && segments[0] != c.receiverID {
		return "", false
	}
	if _, err := time.Parse("02/01/2006", segments[2]); err != nil {
		return "", false
	}
	return segments[0], true
}

func (c *Complaint) Reply(
	ctx context.Context,
	newReplyID uuid.UUID,
	authorID,
	authorIMG,
	authorName,
	body string,
	enterpriseID string,
) (*Reply, error) {
	if c.status > IN_DISCUSSION {
		return nil, &erros.ComplaintClosedError{}
	}
	thisTime := time.Now()
	publisher := domain.DomainEventPublisherInstance()

	newReply := CreateReply(
		newReplyID,
		c.id,
		authorID,
		authorIMG,
		authorName,
		body,
		enterpriseID,
	)

	switch c.replies.Cardinality() {
	case 0:
		err := c.setStatus(STARTED)
		if err != nil {
			return nil, err
		}
		err = publisher.Publish(ctx, NewComplaintStarted(c.id, newReplyID, thisTime))
		if err != nil {
			return nil, err
		}
	case 1:
		err := c.setStatus(IN_DISCUSSION)
		if err != nil {
			return nil, err
		}
		err = publisher.Publish(ctx, NewDiscussionStarted(c.id, newReplyID, thisTime))
		if err != nil {
			return nil, err
		}
	}
	// err := publisher.Publish(ctx, NewComplaintReplied(c.id, newReplyID, thisTime))
	// if err != nil {
	// 	return nil, err
	// }
	c.replies.Add(newReply)
	return newReply, nil
}

/*
Pre:
  - title must not be empty and must have more than 10 characters and less than 80 characters
  - description must not be empty and must have more than 30 characters and less than 120 characters
  - body must not be empty and must have more than 50 characters and less than 250 characters
*/
func Send(
	ctx context.Context,
	id uuid.UUID,
	authorID,
	authorFullName,
	authorProfileIMG,
	receiverID,
	receiverFullName,
	receiverProfileIMG,
	title,
	description,
	body string) (*Complaint, error) {
	var (
		publisher    = domain.DomainEventPublisherInstance()
		message      Message
		newComplaint *Complaint
		nullRating   Rating = Rating{}
		thisDate            = common.NewDate(time.Now())
		status       Status = OPEN
		err          error
		event        domain.DomainEvent
	)
	message, err = NewMessage(title, description, body)
	if err != nil {
		return nil, err
	}
	newComplaint, err = NewComplaint(
		id,
		authorID,
		authorFullName,
		authorProfileIMG,
		receiverID,
		receiverFullName,
		receiverProfileIMG,
		status,
		message,
		thisDate,
		thisDate,
		nullRating,
		mapset.NewSet[*Reply](),
	)
	if err != nil {
		return nil, err
	}
	event = NewComplaintSent(id, authorID, receiverID, thisDate.Date())
	err = publisher.Publish(ctx, event)
	if err != nil {

		return nil, err
	}
	return newComplaint, nil
}

func NewComplaint(
	ID uuid.UUID,
	authorID string,
	authorFullName string,
	authorProfileIMG string,
	receiverID string,
	receiverFullName string,
	receiverProfileIMG string,
	status Status,
	message Message,
	createdAt,
	updatedAt common.Date,
	rating Rating,
	replies mapset.Set[*Reply],
) (*Complaint, error) {
	var c *Complaint = new(Complaint)
	err := c.setID(ID)
	if err != nil {
		return nil, err
	}
	err = c.setStatus(status)
	if err != nil {
		return nil, err
	}
	err = c.setMessage(message)
	if err != nil {
		return nil, err
	}
	err = c.setAuthorID(authorID)
	if err != nil {
		return nil, err
	}
	err = c.setAuthorFullName(authorFullName)
	if err != nil {
		return nil, err
	}
	err = c.setAuthorProfileIMG(authorProfileIMG)
	if err != nil {
		return nil, err
	}
	err = c.setReceiverID(receiverID)
	if err != nil {
		return nil, err
	}
	err = c.setReceiverFullName(receiverFullName)
	if err != nil {
		return nil, err
	}
	err = c.setReceiverProfileIMG(receiverProfileIMG)
	if err != nil {
		return nil, err
	}
	c.setRating(rating)
	err = c.setCreatedAt(createdAt)
	if err != nil {
		return nil, err
	}
	err = c.setUpdatedAt(updatedAt)
	if err != nil {
		return nil, err
	}
	err = c.setReplies(replies)
	if err != nil {
		return nil, err
	}
	c.replies = replies
	return c, nil
}

func (c *Complaint) AddReply(reply *Reply) {
	ok := c.replies.Add(reply)
	if ok {
		c.updatedAt = common.NewDate(time.Now())
	}
}

func (c *Complaint) setAuthorID(author string) error {
	if author == "" {
		return &erros.NullValueError{}
	}
	c.authorID = author
	return nil
}

func (c *Complaint) setAuthorFullName(authorFullName string) error {
	if authorFullName == "" {
		return &erros.NullValueError{}
	}
	c.authorFullName = authorFullName
	return nil
}

func (c *Complaint) setAuthorProfileIMG(authorProfileIMG string) error {
	if authorProfileIMG == "" {
		return &erros.NullValueError{}
	}
	c.authorProfileIMG = authorProfileIMG
	return nil
}

func (c *Complaint) setReceiverID(receiverID string) error {
	if receiverID == "" {
		return &erros.NullValueError{}
	}
	c.receiverID = receiverID
	return nil
}

func (c *Complaint) setReceiverFullName(receiverFullName string) error {
	if receiverFullName == "" {
		return &erros.NullValueError{}
	}
	c.receiverFullName = receiverFullName
	return nil
}

func (c *Complaint) setReceiverProfileIMG(receiverProfileIMG string) error {
	if receiverProfileIMG == "" {
		return &erros.NullValueError{}
	}
	c.receiverProfileIMG = receiverProfileIMG
	return nil
}

// nullable
func (c *Complaint) setRating(rating Rating) {
	if rating == (Rating{}) {
		rating = Rating{
			rate:    0,
			comment: "",
		}
	}
	c.rating = rating
}

func (c *Complaint) setID(id uuid.UUID) error {
	if id == uuid.Nil {
		return &erros.NullValueError{}
	}
	c.id = id
	return nil
}

func (c *Complaint) setStatus(status Status) error {
	if status < 0 || status > 5 {
		return &erros.ValidationError{
			Expected: "a value between 0 and 5",
		}
	}
	c.status = status
	return nil
}

func (c *Complaint) setMessage(message Message) error {
	if message == (Message{}) {
		return &erros.NullValueError{}
	}
	c.message = message
	return nil
}

func (c *Complaint) setCreatedAt(createdAt common.Date) error {
	if createdAt == (common.Date{}) {
		return &erros.EmptyStructError{}
	}
	c.createdAt = createdAt
	return nil
}

func (c *Complaint) setUpdatedAt(updatedAt common.Date) error {
	if updatedAt == (common.Date{}) {
		return &erros.EmptyStructError{}
	}
	c.updatedAt = updatedAt
	return nil
}

func (c *Complaint) setReplies(replies mapset.Set[*Reply]) error {
	if replies == nil {
		return &erros.NullValueError{}
	}
	c.replies = replies
	return nil
}

func (c Complaint) ID() uuid.UUID {
	return c.id
}

func (c Complaint) AuthorID() string {
	return c.authorID
}

func (c Complaint) AuthorFullName() string {
	return c.authorFullName
}

func (c Complaint) AuthorProfileIMG() string {
	return c.authorProfileIMG
}

func (c Complaint) ReceiverID() string {
	return c.receiverID
}

func (c Complaint) ReceiverFullName() string {
	return c.receiverFullName
}

func (c Complaint) ReceiverProfileIMG() string {
	return c.receiverProfileIMG
}

func (c Complaint) Status() Status {
	return c.status
}

func (c Complaint) Message() Message {
	return c.message
}

func (c Complaint) Rating() Rating {
	return c.rating
}

func (c Complaint) CreatedAt() common.Date {
	return c.createdAt
}

func (c Complaint) UpdatedAt() common.Date {
	return c.updatedAt
}

func (c Complaint) Replies() mapset.Set[Reply] {
	valueCopy := mapset.NewSet[Reply]()
	for reply := range c.replies.Iter() {
		valueCopy.Add(*reply)
	}
	return valueCopy
}

func (c *Complaint) MarkRepliesAsSeen(parsedIds mapset.Set[uuid.UUID]) int {
	replies := c.replies.ToSlice()
	count := 0
	for _, reply := range replies {
		if parsedIds.Contains(reply.ID()) {
			reply.MarkAsRead()
			count++
		}
	}
	c.replies = mapset.NewSet(replies...)
	return count
}

func (c Complaint) RepliesDifference(replies mapset.Set[*Reply]) mapset.Set[Reply] {
	valueCopy := mapset.NewSet[Reply]()
	difference := c.replies.Difference(replies)
	for reply := range difference.Iter() {
		valueCopy.Add(*reply)
	}
	return valueCopy
}

func (c Complaint) LastReply() Reply {
	var lastReply Reply
	if c.replies.Cardinality() == 0 {
		return lastReply
	}
	sliceCopy := c.replies.ToSlice()
	slices.SortStableFunc(sliceCopy, func(i, j *Reply) int {
		if i.createdAt.Date().Before(j.createdAt.Date()) {
			return -1
		}
		if i.createdAt.Date().After(j.createdAt.Date()) {
			return 1
		}
		return 0
	})
	return *sliceCopy[len(sliceCopy)-1]
}
