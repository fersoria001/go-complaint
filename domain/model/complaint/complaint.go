package complaint

import (
	"context"
	"go-complaint/domain"
	"go-complaint/domain/model/common"
	"go-complaint/erros"
	"net/mail"
	"strings"
	"time"

	"github.com/google/uuid"
)

/*
*
<<Entity>>
<<Value Object>> Status 1
<<Value Object>> Message 1
<<Value Object>> Rating 1
<<Value Object>> ReceiverID 1
Relationships:
- Complaint *..1 Author trough AuthorID
- Complaint *..1 Status
- Complaint *..1 Message
- Complaint *..1 Rating
- Complaint *..1 ReceiverID trough ReceiverID
- Complaint 1..* Reply  trough ID
*/
type Complaint struct {
	id         uuid.UUID
	authorID   string
	receiverID string
	status     Status
	message    Message
	rating     Rating
	createdAt  common.Date
	updatedAt  common.Date
}

/*
validated by the requester ID
if its an email then its an user and it must match the author
-users can only close their own complaints-
if its an employee ID then it must match the enterprise
-employees can close sent or received complaints from their enterprise-
*/
func (complaint *Complaint) Close(
	ctx context.Context,
	closeRequesterID string,
) error {
	if complaint.Status() >= CLOSED {
		return &erros.ComplaintClosedError{}
	}
	if complaint.Status() < IN_DISCUSSION {
		return &erros.ValidationError{
			Expected: "a complaint must be in discussion to be closed by user or in review to be closed by enterprise employee",
		}
	}
	_, err := mail.ParseAddress(closeRequesterID)
	if err != nil {
		enterpriseName, ok := complaint.IsValidEmployeeID(closeRequesterID)
		if !ok {
			return &erros.ValidationError{
				Expected: "a valid email or employee ID",
			}
		}
		if enterpriseName != complaint.authorID && enterpriseName != complaint.receiverID {
			return &erros.ValidationError{
				Expected: "a valid employee ID for this enterprise ",
			}
		}
		if complaint.status != IN_REVIEW {
			return &erros.ValidationError{
				Expected: "a complaint in review status to be closed by an employee",
			}
		}
		err := complaint.setStatus(CLOSED)
		if err != nil {
			return err
		}
		return domain.DomainEventPublisherInstance().Publish(
			ctx,
			NewEnterpriseComplaintClosed(
				complaint.id,
				enterpriseName,
			),
		)
	}
	if closeRequesterID != complaint.authorID {
		return &erros.ValidationError{
			Expected: "the requester ID must match the author ID",
		}
	}
	if complaint.status != IN_DISCUSSION {
		return &erros.ValidationError{
			Expected: "a complaint in discussion status to be closed by user",
		}
	}
	err = complaint.setStatus(CLOSED)
	if err != nil {
		return err
	}
	return domain.DomainEventPublisherInstance().Publish(
		ctx,
		NewUserComplaintClosed(
			complaint.id,
			closeRequesterID,
		),
	)
}

func (complaint *Complaint) Rate(ctx context.Context, authorID string, rate int, comment string) error {
	if complaint.Status() < IN_REVIEW ||
		complaint.Status() > CLOSED {
		return &erros.ValidationError{
			Expected: "a complaint must be in review or closed to be rated",
		}
	}
	if authorID != complaint.authorID {
		return &erros.ValidationError{
			Expected: "the requester ID must match the author ID",
		}
	}
	var (
		err    error
		rating *Rating
	)
	rating, err = NewRating(rate, comment)
	if err != nil {
		return err
	}
	complaint.rating = *rating
	return nil
}

/*
It can be a received or sent complaint
validated trough the employee ID
*/
func (complaint *Complaint) MarkAsReviewable(
	ctx context.Context,
	assistantID string,
) error {
	enterpriseName, ok := complaint.IsValidEmployeeID(assistantID)
	if !ok {
		return &erros.ValidationError{
			Expected: "a valid employee ID for this enterprise",
		}
	}
	if complaint.status >= IN_REVIEW {
		return &erros.ComplaintClosedError{}
	}
	err := complaint.setStatus(IN_REVIEW)
	if err != nil {
		return err
	}
	return domain.DomainEventPublisherInstance().Publish(
		ctx,
		NewWaitingForReview(
			complaint.id,
			enterpriseName,
			assistantID,
		),
	)
}

/*
It must be generated by application
4 segments
- enterpriseID that match the current enterprise author or receiver
- manager who whire the employee email
- hiring date in 02/01/2006 format
- string random segment of uuid
*/
func (c *Complaint) IsValidEmployeeID(employeeID string) (string, bool) {
	segments := strings.Split(employeeID, "-")
	if len(segments) != 4 {
		return "", false
	}
	if segments[0] != c.authorID && segments[0] != c.receiverID {
		return "", false
	}
	if _, err := time.Parse("02/01/2006", segments[2]); err != nil {
		return "", false
	}
	return segments[0], true
}

func (c *Complaint) ReplyComplaint(
	ctx context.Context,
	count int,
	senderID,
	senderIMG,
	senderName,
	body string) (*Reply, error) {
	if c.status > IN_DISCUSSION {
		return nil, &erros.ComplaintClosedError{}
	}
	var (
		publisher  = domain.DomainEventPublisherInstance()
		thisDate   = common.NewDate(time.Now())
		thisTime   = thisDate.Date()
		newReplyID = uuid.New()
		newReply   *Reply
		err        error
	)

	newReply, err = NewReply(
		newReplyID,
		c.id,
		senderID,
		senderIMG,
		senderName,
		body,
		false,
		thisDate,
		thisDate,
		thisDate)
	if err != nil {
		return nil, err
	}
	switch count {
	case 0:
		err := c.setStatus(STARTED)
		if err != nil {
			return nil, err
		}
		err = publisher.Publish(ctx, NewComplaintStarted(c.id, newReplyID, thisTime))
		if err != nil {
			return nil, err
		}
	case 1:
		err := c.setStatus(IN_DISCUSSION)
		if err != nil {
			return nil, err
		}
		err = publisher.Publish(ctx, NewDiscussionStarted(c.id, newReplyID, thisTime))
		if err != nil {
			return nil, err
		}
	}
	err = publisher.Publish(ctx, NewComplaintReplied(c.id, newReplyID, thisTime))
	if err != nil {
		return nil, err
	}

	return newReply, nil
}

/*
Pre:
  - title must not be empty and must have more than 10 characters and less than 80 characters
  - description must not be empty and must have more than 30 characters and less than 120 characters
  - body must not be empty and must have more than 50 characters and less than 250 characters
*/
func SendComplaint(
	ctx context.Context,
	authorID,
	receiverID,
	title,
	description,
	body string) (*Complaint, error) {
	var (
		publisher      = domain.DomainEventPublisherInstance()
		message        Message
		newComplaint   *Complaint
		newComplaintID uuid.UUID = uuid.New()
		nullRating     Rating    = Rating{}
		thisDate                 = common.NewDate(time.Now())
		status         Status    = OPEN
		err            error
		event          domain.DomainEvent
	)
	message, err = NewMessage(title, description, body)
	if err != nil {
		return nil, err
	}
	newComplaint, err = NewComplaint(
		newComplaintID,
		authorID,
		receiverID,
		status,
		message,
		thisDate,
		thisDate,
		nullRating)
	if err != nil {
		return nil, err
	}
	event = NewComplaintSent(newComplaintID, authorID, receiverID, thisDate.Date())
	err = publisher.Publish(ctx, event)
	if err != nil {
		return nil, err
	}
	return newComplaint, nil
}

func NewComplaint(ID uuid.UUID,
	authorID string, receiverID string,
	status Status, message Message,
	createdAt, updatedAt common.Date,
	rating Rating) (*Complaint, error) {
	var c *Complaint = new(Complaint)
	err := c.setID(ID)
	if err != nil {
		return nil, err
	}
	err = c.setStatus(status)
	if err != nil {
		return nil, err
	}
	err = c.setMessage(message)
	if err != nil {
		return nil, err
	}
	err = c.setAuthorID(authorID)
	if err != nil {
		return nil, err
	}
	err = c.setReceiverID(receiverID)
	if err != nil {
		return nil, err
	}
	c.setRating(rating)
	err = c.setCreatedAt(createdAt)
	if err != nil {
		return nil, err
	}
	err = c.setUpdatedAt(updatedAt)
	if err != nil {
		return nil, err
	}
	return c, nil
}

func (c *Complaint) setAuthorID(author string) error {
	if author == "" {
		return &erros.NullValueError{}
	}
	c.authorID = author
	return nil
}

func (c *Complaint) setReceiverID(receiverID string) error {
	if receiverID == "" {
		return &erros.NullValueError{}
	}
	c.receiverID = receiverID
	return nil
}

// nullable
func (c *Complaint) setRating(rating Rating) {
	if rating == (Rating{}) {
		rating = Rating{
			rate:    0,
			comment: "",
		}
	}
	c.rating = rating
}

func (c *Complaint) setID(id uuid.UUID) error {
	if id == uuid.Nil {
		return &erros.NullValueError{}
	}
	c.id = id
	return nil
}

func (c *Complaint) setStatus(status Status) error {
	if status < 0 || status > 5 {
		return &erros.ValidationError{
			Expected: "a value between 0 and 5",
		}
	}
	c.status = status
	return nil
}

func (c *Complaint) setMessage(message Message) error {
	if message == (Message{}) {
		return &erros.NullValueError{}
	}
	c.message = message
	return nil
}

func (c *Complaint) setCreatedAt(createdAt common.Date) error {
	if createdAt == (common.Date{}) {
		return &erros.EmptyStructError{}
	}
	c.createdAt = createdAt
	return nil
}

func (c *Complaint) setUpdatedAt(updatedAt common.Date) error {
	if updatedAt == (common.Date{}) {
		return &erros.EmptyStructError{}
	}
	c.updatedAt = updatedAt
	return nil
}

func (c *Complaint) ID() uuid.UUID {
	return c.id
}

func (c *Complaint) AuthorID() string {
	return c.authorID
}

func (c *Complaint) ReceiverID() string {
	return c.receiverID
}

func (c *Complaint) Status() Status {
	return c.status
}

func (c *Complaint) Message() Message {
	return c.message
}

func (c *Complaint) Rating() Rating {
	return c.rating
}

func (c *Complaint) CreatedAt() common.Date {
	return c.createdAt
}

func (c *Complaint) UpdatedAt() common.Date {
	return c.updatedAt
}
