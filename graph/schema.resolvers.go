package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"fmt"
	"go-complaint/application"
	"go-complaint/application/application_services"
	"go-complaint/application/commands"
	"go-complaint/application/queries"
	"go-complaint/dto"
	"go-complaint/graph/model"
	"log"

	pgx "github.com/jackc/pgx/v5"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUser) (*model.User, error) {
	c := commands.NewRegisterUserCommand(
		input.UserName,
		input.Password,
		input.FirstName,
		input.LastName,
		input.Genre,
		input.Pronoun,
		input.BirthDate,
		input.PhoneNumber,
		"/default.jpg",
		input.CountryID,
		input.CityID,
		input.CountryStateID,
	)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewUserByUsernameQuery(input.UserName)
	user, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.User{
		//Id: user.Id,
		UserName: user.Username,
		Person: &model.Person{
			ProfileImg:  user.Person.ProfileImg,
			Email:       user.Person.Email,
			FirstName:   user.Person.FirstName,
			LastName:    user.Person.LastName,
			Genre:       user.Person.Genre,
			Pronoun:     user.Person.Pronoun,
			Age:         user.Person.Age,
			PhoneNumber: user.Person.Phone,
			Address: &model.Address{
				Country:      user.Person.Address.Country,
				CountryState: user.Person.Address.County,
				City:         user.Person.Address.City,
			},
		},
		Status: model.UserStatusOffline,
	}, nil
}

// CreateEnterprise is the resolver for the createEnterprise field.
func (r *mutationResolver) CreateEnterprise(ctx context.Context, input model.CreateEnterprise) (*model.Enterprise, error) {
	currentUser, err := application_services.AuthorizationApplicationServiceInstance().Credentials(ctx)
	if err != nil {
		return nil, err
	}
	c := commands.NewRegisterEnterpriseCommand(
		currentUser.Id,
		input.Name,
		"/default.jpg",
		"/banner.jpg",
		input.Website,
		input.Email,
		input.PhoneNumber,
		input.FoundationDate,
		input.IndustryID,
		input.CountryID,
		input.CountryStateID,
		input.CityID,
	)
	err = c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewEnterpriseByNameQuery(input.Name)
	enterprise, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	employees := make([]*model.Employee, 0, len(enterprise.Employees))
	for _, v := range enterprise.Employees {
		employees = append(employees, &model.Employee{
			ID:           v.ID.String(),
			EnterpriseID: v.EnterpriseID,
			UserID:       v.UserID,
			User: &model.User{
				UserName: v.Email,
				Person: &model.Person{
					ProfileImg:  v.ProfileIMG,
					Email:       v.Email,
					FirstName:   v.FirstName,
					LastName:    v.LastName,
					Genre:       "",
					Pronoun:     "",
					Age:         v.Age,
					PhoneNumber: v.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         v.HiringDate,
			ApprovedHiring:     v.ApprovedHiring,
			ApprovedHiringAt:   v.ApprovedHiringAt,
			EnterprisePosition: v.Position,
		})
	}
	return &model.Enterprise{
		Name:        enterprise.Name,
		LogoImg:     enterprise.LogoIMG,
		BannerImg:   enterprise.BannerIMG,
		Website:     enterprise.Website,
		Email:       enterprise.Email,
		PhoneNumber: enterprise.Phone,
		Address: &model.Address{
			Country:      enterprise.Address.Country,
			CountryState: enterprise.Address.County,
			City:         enterprise.Address.City,
		},
		Industry:       enterprise.Industry,
		FoundationDate: enterprise.FoundationDate,
		OwnerID:        enterprise.OwnerID,
		Employees:      employees,
	}, nil
}

// CreateNewComplaint is the resolver for the createNewComplaint field.
func (r *mutationResolver) CreateNewComplaint(ctx context.Context, input model.CreateNewComplaint) (*model.Complaint, error) {
	c := commands.NewCreateNewComplaintCommand(input.AuthorID, input.ReceiverID)
	err := c.Execute(ctx)
	if !errors.Is(err, commands.ErrComplaintAlreadyExists) {
		return nil, err
	}

	q := queries.NewComplaintInWritingStatusQuery(input.AuthorID, input.ReceiverID)
	dbc, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
	for _, v := range dbc.Replies {
		replies = append(replies, &model.ComplaintReply{
			ID:          v.Id,
			ComplaintID: v.ComplaintId,
			Sender: &model.Recipient{
				ID:               v.Sender.Id,
				SubjectName:      &v.Sender.SubjectName,
				SubjectThumbnail: &v.Sender.SubjectThumbnail,
				SubjectEmail:     &v.Sender.SubjectEmail,
				IsEnterprise:     &v.Sender.IsEnterprise,
			},
			Body:      v.Body,
			CreatedAt: v.CreatedAt,
			Read:      &v.Read,
			ReadAt:    v.ReadAt,
			UpdatedAt: v.UpdatedAt,
		})
	}
	return &model.Complaint{
		ID: dbc.Id,
		Author: &model.Recipient{
			ID:               dbc.Author.Id,
			SubjectName:      &dbc.Author.SubjectName,
			SubjectThumbnail: &dbc.Author.SubjectThumbnail,
			SubjectEmail:     &dbc.Author.SubjectEmail,
			IsEnterprise:     &dbc.Author.IsEnterprise,
		},
		Receiver: &model.Recipient{
			ID:               dbc.Receiver.Id,
			SubjectName:      &dbc.Receiver.SubjectName,
			SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
			SubjectEmail:     &dbc.Receiver.SubjectEmail,
			IsEnterprise:     &dbc.Receiver.IsEnterprise,
		},
		Status:      model.ComplaintStatus(dbc.Status),
		Title:       dbc.Title,
		Description: dbc.Description,
		Rating: &model.Rating{
			ID:      dbc.Rating.Id,
			Rate:    dbc.Rating.Rate,
			Comment: dbc.Rating.Comment,
		},
		CreatedAt: dbc.CreatedAt,
		UpdatedAt: dbc.UpdatedAt,
		Replies:   replies,
	}, nil
}

// DescribeComplaint is the resolver for the describeComplaint field.
func (r *mutationResolver) DescribeComplaint(ctx context.Context, input model.DescribeComplaint) (*model.Complaint, error) {
	c := commands.NewDescribeComplaintCommand(input.ComplaintID, input.Description, input.Title)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewComplaintByIdQuery(input.ComplaintID)
	dbc, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
	for _, v := range dbc.Replies {
		replies = append(replies, &model.ComplaintReply{
			ID:          v.Id,
			ComplaintID: v.ComplaintId,
			Sender: &model.Recipient{
				ID:               v.Sender.Id,
				SubjectName:      &v.Sender.SubjectName,
				SubjectThumbnail: &v.Sender.SubjectThumbnail,
				SubjectEmail:     &v.Sender.SubjectEmail,
				IsEnterprise:     &v.Sender.IsEnterprise,
			},
			Body:      v.Body,
			CreatedAt: v.CreatedAt,
			Read:      &v.Read,
			ReadAt:    v.ReadAt,
			UpdatedAt: v.UpdatedAt,
		})
	}
	return &model.Complaint{
		ID: dbc.Id,
		Author: &model.Recipient{
			ID:               dbc.Author.Id,
			SubjectName:      &dbc.Author.SubjectName,
			SubjectThumbnail: &dbc.Author.SubjectThumbnail,
			SubjectEmail:     &dbc.Author.SubjectEmail,
			IsEnterprise:     &dbc.Author.IsEnterprise,
		},
		Receiver: &model.Recipient{
			ID:               dbc.Receiver.Id,
			SubjectName:      &dbc.Receiver.SubjectName,
			SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
			SubjectEmail:     &dbc.Receiver.SubjectEmail,
			IsEnterprise:     &dbc.Receiver.IsEnterprise,
		},
		Status:      model.ComplaintStatus(dbc.Status),
		Title:       dbc.Title,
		Description: dbc.Description,
		Rating: &model.Rating{
			ID:      dbc.Rating.Id,
			Rate:    dbc.Rating.Rate,
			Comment: dbc.Rating.Comment,
		},
		CreatedAt: dbc.CreatedAt,
		UpdatedAt: dbc.UpdatedAt,
		Replies:   replies,
	}, nil
}

// SendComplaint is the resolver for the sendComplaint field.
func (r *mutationResolver) SendComplaint(ctx context.Context, input model.SendComplaint) (*model.Complaint, error) {
	c := commands.NewSendComplaintCommand(input.ComplaintID, input.Body)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewComplaintByIdQuery(input.ComplaintID)
	dbc, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
	for _, v := range dbc.Replies {
		replies = append(replies, &model.ComplaintReply{
			ID:          v.Id,
			ComplaintID: v.ComplaintId,
			Sender: &model.Recipient{
				ID:               v.Sender.Id,
				SubjectName:      &v.Sender.SubjectName,
				SubjectThumbnail: &v.Sender.SubjectThumbnail,
				SubjectEmail:     &v.Sender.SubjectEmail,
				IsEnterprise:     &v.Sender.IsEnterprise,
			},
			Body:      v.Body,
			CreatedAt: v.CreatedAt,
			Read:      &v.Read,
			ReadAt:    v.ReadAt,
			UpdatedAt: v.UpdatedAt,
		})
	}
	return &model.Complaint{
		ID: dbc.Id,
		Author: &model.Recipient{
			ID:               dbc.Author.Id,
			SubjectName:      &dbc.Author.SubjectName,
			SubjectThumbnail: &dbc.Author.SubjectThumbnail,
			SubjectEmail:     &dbc.Author.SubjectEmail,
			IsEnterprise:     &dbc.Author.IsEnterprise,
		},
		Receiver: &model.Recipient{
			ID:               dbc.Receiver.Id,
			SubjectName:      &dbc.Receiver.SubjectName,
			SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
			SubjectEmail:     &dbc.Receiver.SubjectEmail,
			IsEnterprise:     &dbc.Receiver.IsEnterprise,
		},
		Status:      model.ComplaintStatus(dbc.Status),
		Title:       dbc.Title,
		Description: dbc.Description,
		Rating: &model.Rating{
			ID:      dbc.Rating.Id,
			Rate:    dbc.Rating.Rate,
			Comment: dbc.Rating.Comment,
		},
		CreatedAt: dbc.CreatedAt,
		UpdatedAt: dbc.UpdatedAt,
		Replies:   replies,
	}, nil
}

// UserDescriptor is the resolver for the userDescriptor field.
func (r *queryResolver) UserDescriptor(ctx context.Context) (*model.UserDescriptor, error) {
	currentUser, err := application_services.AuthorizationApplicationServiceInstance().Credentials(ctx)
	if err != nil {
		return nil, err
	}
	authorities := make([]*model.GrantedAuthority, 0, len(currentUser.GrantedAuthorities))
	for _, v := range currentUser.GrantedAuthorities {
		authorities = append(authorities, &model.GrantedAuthority{
			EnterpriseID: v.EnterpriseID,
			Principal:    v.Principal,
			Authority:    v.Authority,
		})
	}

	return &model.UserDescriptor{
		ID:          currentUser.Id,
		UserName:    currentUser.Email,
		FullName:    currentUser.FullName,
		ProfileImg:  currentUser.ProfileImg,
		Genre:       currentUser.Genre,
		Pronoun:     currentUser.Pronoun,
		Authorities: authorities,
	}, nil
}

// Countries is the resolver for the countries field.
func (r *queryResolver) Countries(ctx context.Context) ([]*model.Country, error) {
	q := queries.NewAllCountriesQuery()
	countries, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Country, 0, len(countries))
	for _, v := range countries {
		result = append(result, &model.Country{
			ID:        v.Id,
			Name:      v.Name,
			PhoneCode: v.PhoneCode,
		})
	}
	return result, nil
}

// CountryStates is the resolver for the countryStates field.
func (r *queryResolver) CountryStates(ctx context.Context, id int) ([]*model.CountryState, error) {
	q := queries.NewCountryStatesByCountryIdQuery(id)
	countryStates, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	result := make([]*model.CountryState, 0, len(countryStates))
	for _, v := range countryStates {
		result = append(result, &model.CountryState{
			ID:   v.Id,
			Name: v.Name,
		})
	}
	return result, nil
}

// Cities is the resolver for the cities field.
func (r *queryResolver) Cities(ctx context.Context, id int) ([]*model.City, error) {
	q := queries.NewCitiesByCountryStateIdQuery(id)
	cities, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	result := make([]*model.City, 0, len(cities))
	for _, v := range cities {
		result = append(result, &model.City{
			ID:          v.Id,
			Name:        v.Name,
			CountryCode: v.CountryCode,
			Latitude:    v.Latitude,
			Longitude:   v.Longitude,
		})
	}
	return result, nil
}

// Industries is the resolver for the industries field.
func (r *queryResolver) Industries(ctx context.Context) ([]*model.Industry, error) {
	q := queries.IndustryQuery{}
	industries, err := q.AllIndustries(ctx)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Industry, 0, len(industries))
	for _, v := range industries {
		result = append(result, &model.Industry{
			ID:   v.ID,
			Name: v.Name,
		})
	}
	return result, nil
}

// RecipientsByNameLike is the resolver for the recipientsByNameLike field.
func (r *queryResolver) RecipientsByNameLike(ctx context.Context, term string) ([]*model.Recipient, error) {
	svc := application_services.AuthorizationApplicationServiceInstance()
	currentUser, err := svc.Credentials(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewFindRecipientsByNameLikeQuery(currentUser.Id, term)
	recipients, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Recipient, 0, len(recipients))
	for _, v := range recipients {
		result = append(result, &model.Recipient{
			ID:               v.Id,
			SubjectName:      &v.SubjectName,
			SubjectThumbnail: &v.SubjectThumbnail,
			SubjectEmail:     &v.SubjectEmail,
			IsEnterprise:     &v.IsEnterprise,
		})
	}
	return result, nil
}

// ComplaintByID is the resolver for the complaintById field.
func (r *queryResolver) ComplaintByID(ctx context.Context, id string) (*model.Complaint, error) {
	c := queries.NewComplaintByIdQuery(id)
	dbc, err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
	for _, v := range dbc.Replies {
		replies = append(replies, &model.ComplaintReply{
			ID:          v.Id,
			ComplaintID: v.ComplaintId,
			Sender: &model.Recipient{
				ID:               v.Sender.Id,
				SubjectName:      &v.Sender.SubjectName,
				SubjectThumbnail: &v.Sender.SubjectThumbnail,
				SubjectEmail:     &v.Sender.SubjectEmail,
				IsEnterprise:     &v.Sender.IsEnterprise,
			},
			Body:      v.Body,
			CreatedAt: v.CreatedAt,
			Read:      &v.Read,
			ReadAt:    v.ReadAt,
			UpdatedAt: v.UpdatedAt,
		})
	}
	return &model.Complaint{
		ID: dbc.Id,
		Author: &model.Recipient{
			ID:               dbc.Author.Id,
			SubjectName:      &dbc.Author.SubjectName,
			SubjectThumbnail: &dbc.Author.SubjectThumbnail,
			SubjectEmail:     &dbc.Author.SubjectEmail,
			IsEnterprise:     &dbc.Author.IsEnterprise,
		},
		Receiver: &model.Recipient{
			ID:               dbc.Receiver.Id,
			SubjectName:      &dbc.Receiver.SubjectName,
			SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
			SubjectEmail:     &dbc.Receiver.SubjectEmail,
			IsEnterprise:     &dbc.Receiver.IsEnterprise,
		},
		Status:      model.ComplaintStatus(dbc.Status),
		Title:       dbc.Title,
		Description: dbc.Description,
		Rating: &model.Rating{
			ID:      dbc.Rating.Id,
			Rate:    dbc.Rating.Rate,
			Comment: dbc.Rating.Comment,
		},
		CreatedAt: dbc.CreatedAt,
		UpdatedAt: dbc.UpdatedAt,
		Replies:   replies,
	}, nil
}

// ComplaintsInfo is the resolver for the complaintsInfo field.
func (r *queryResolver) ComplaintsInfo(ctx context.Context, id string) (*model.ComplaintsInfo, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"rid",
		id,
		application_services.READ,
		"MANAGER", "ASSISTANT", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	q := queries.NewComplaintDataByOwnerIdQuery(id)
	c, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	received := make([]*model.ComplaintData, 0)
	resolved := make([]*model.ComplaintData, 0)
	reviewed := make([]*model.ComplaintData, 0)
	sent := make([]*model.ComplaintData, 0)
	for _, v := range c.Received {
		received = append(received, &model.ComplaintData{
			ID:          v.Id,
			OwnerID:     v.OwnerId,
			ComplaintID: v.ComplaintId,
			OccurredOn:  v.OccurredOn,
			DataType:    model.ComplaintDataType(v.DataType),
		})
	}
	for _, v := range c.Resolved {
		resolved = append(resolved, &model.ComplaintData{
			ID:          v.Id,
			OwnerID:     v.OwnerId,
			ComplaintID: v.ComplaintId,
			OccurredOn:  v.OccurredOn,
			DataType:    model.ComplaintDataType(v.DataType),
		})
	}
	for _, v := range c.Reviewed {
		reviewed = append(reviewed, &model.ComplaintData{
			ID:          v.Id,
			OwnerID:     v.OwnerId,
			ComplaintID: v.ComplaintId,
			OccurredOn:  v.OccurredOn,
			DataType:    model.ComplaintDataType(v.DataType),
		})
	}
	for _, v := range c.Sent {
		sent = append(sent, &model.ComplaintData{
			ID:          v.Id,
			OwnerID:     v.OwnerId,
			ComplaintID: v.ComplaintId,
			OccurredOn:  v.OccurredOn,
			DataType:    model.ComplaintDataType(v.DataType),
		})
	}
	return &model.ComplaintsInfo{
		Received: received,
		Resolved: resolved,
		Reviewed: reviewed,
		Sent:     sent,
	}, nil
}

// ComplaintsByAuthorOrReceiverID is the resolver for the complaintsByAuthorOrReceiverId field.
func (r *queryResolver) ComplaintsByAuthorOrReceiverID(ctx context.Context, id string) ([]*model.Complaint, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"rid",
		id,
		application_services.READ,
		"MANAGER", "ASSISTANT", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	q := queries.NewComplaintsByAuthorOrReceiverIdQuery(id)
	dbcs, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.Complaint, 0, len(dbcs))
	for _, dbc := range dbcs {
		replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
		for _, v := range dbc.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          v.Id,
				ComplaintID: v.ComplaintId,
				Sender: &model.Recipient{
					ID:               v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:      v.Body,
				CreatedAt: v.CreatedAt,
				Read:      &v.Read,
				ReadAt:    v.ReadAt,
				UpdatedAt: v.UpdatedAt,
			})
		}
		results = append(results, &model.Complaint{
			ID: dbc.Id,
			Author: &model.Recipient{
				ID:               dbc.Author.Id,
				SubjectName:      &dbc.Author.SubjectName,
				SubjectThumbnail: &dbc.Author.SubjectThumbnail,
				SubjectEmail:     &dbc.Author.SubjectEmail,
				IsEnterprise:     &dbc.Author.IsEnterprise,
			},
			Receiver: &model.Recipient{
				ID:               dbc.Receiver.Id,
				SubjectName:      &dbc.Receiver.SubjectName,
				SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
				SubjectEmail:     &dbc.Receiver.SubjectEmail,
				IsEnterprise:     &dbc.Receiver.IsEnterprise,
			},
			Status:      model.ComplaintStatus(dbc.Status),
			Title:       dbc.Title,
			Description: dbc.Description,
			Rating: &model.Rating{
				ID:      dbc.Rating.Id,
				Rate:    dbc.Rating.Rate,
				Comment: dbc.Rating.Comment,
			},
			CreatedAt: dbc.CreatedAt,
			UpdatedAt: dbc.UpdatedAt,
			Replies:   replies,
		})
	}
	return results, nil
}

// EnterpriseByID is the resolver for the enterpriseById field.
func (r *queryResolver) EnterpriseByName(ctx context.Context, name string) (*model.Enterprise, error) {
	q := queries.NewEnterpriseByNameQuery(name)
	enterprise, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	employees := make([]*model.Employee, 0, len(enterprise.Employees))
	for _, v := range enterprise.Employees {
		employees = append(employees, &model.Employee{
			ID:           v.ID.String(),
			EnterpriseID: v.EnterpriseID,
			UserID:       v.UserID,
			User: &model.User{
				UserName: v.Email,
				Person: &model.Person{
					ProfileImg:  v.ProfileIMG,
					Email:       v.Email,
					FirstName:   v.FirstName,
					LastName:    v.LastName,
					Genre:       "",
					Pronoun:     "",
					Age:         v.Age,
					PhoneNumber: v.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         v.HiringDate,
			ApprovedHiring:     v.ApprovedHiring,
			ApprovedHiringAt:   v.ApprovedHiringAt,
			EnterprisePosition: v.Position,
		})
	}
	return &model.Enterprise{
		ID:          enterprise.Id,
		Name:        enterprise.Name,
		LogoImg:     enterprise.LogoIMG,
		BannerImg:   enterprise.BannerIMG,
		Website:     enterprise.Website,
		Email:       enterprise.Email,
		PhoneNumber: enterprise.Phone,
		Address: &model.Address{
			Country:      enterprise.Address.Country,
			CountryState: enterprise.Address.County,
			City:         enterprise.Address.City,
		},
		Industry:       enterprise.Industry,
		FoundationDate: enterprise.FoundationDate,
		OwnerID:        enterprise.OwnerID,
		Employees:      employees,
	}, nil
}

// EnterprisesByAuthenticatedUser is the resolver for the enterprisesByAuthenticatedUser field.
func (r *queryResolver) EnterprisesByAuthenticatedUser(ctx context.Context) (*model.EnterprisesByAuthenticatedUserResult, error) {
	currentUser, err := application_services.AuthorizationApplicationServiceInstance().Credentials(ctx)
	if err != nil {
		return nil, err
	}
	owned := make([]*model.EnterpriseByAuthenticatedUser, 0)
	employed := make([]*model.EnterpriseByAuthenticatedUser, 0)
	for _, v := range currentUser.GrantedAuthorities {
		q := queries.NewEnterpriseByIdQuery(v.EnterpriseID)
		enterprise, err := q.Execute(ctx)
		if errors.Is(err, pgx.ErrNoRows) {
			return &model.EnterprisesByAuthenticatedUserResult{
				Enterprises: owned,
				Offices:     employed,
			}, nil
		}
		if err != nil && !errors.Is(err, pgx.ErrNoRows) {
			return nil, err
		}
		employees := make([]*model.Employee, 0, len(enterprise.Employees))
		for _, v := range enterprise.Employees {
			employees = append(employees, &model.Employee{
				ID:           v.ID.String(),
				EnterpriseID: v.EnterpriseID,
				UserID:       v.UserID,
				User: &model.User{
					UserName: v.Email,
					Person: &model.Person{
						ProfileImg:  v.ProfileIMG,
						Email:       v.Email,
						FirstName:   v.FirstName,
						LastName:    v.LastName,
						Genre:       "",
						Pronoun:     "",
						Age:         v.Age,
						PhoneNumber: v.Phone,
						Address:     &model.Address{},
					},
					Status: model.UserStatusOffline,
				},
				HiringDate:         v.HiringDate,
				ApprovedHiring:     v.ApprovedHiring,
				ApprovedHiringAt:   v.ApprovedHiringAt,
				EnterprisePosition: v.Position,
			})
		}
		model := &model.EnterpriseByAuthenticatedUser{
			Authority: &model.GrantedAuthority{
				Authority:    v.Authority,
				EnterpriseID: v.EnterpriseID,
			},
			Enterprise: &model.Enterprise{
				Name:        enterprise.Name,
				LogoImg:     enterprise.LogoIMG,
				BannerImg:   enterprise.BannerIMG,
				Website:     enterprise.Website,
				Email:       enterprise.Email,
				PhoneNumber: enterprise.Phone,
				Address: &model.Address{
					Country:      enterprise.Address.Country,
					CountryState: enterprise.Address.County,
					City:         enterprise.Address.City,
				},
				Industry:       enterprise.Industry,
				FoundationDate: enterprise.FoundationDate,
				OwnerID:        enterprise.OwnerID,
				Employees:      employees,
			},
		}
		if v.Authority == "OWNER" {
			owned = append(owned, model)
		} else {
			employed = append(employed, model)
		}
	}
	return &model.EnterprisesByAuthenticatedUserResult{
		Enterprises: owned,
		Offices:     employed,
	}, nil
}

// UsersForHiring is the resolver for the usersForHiring field.
func (r *queryResolver) UsersForHiring(ctx context.Context, input model.SearchWithPagination) (*model.UsersForHiringResult, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"Enterprise",
		input.ID,
		application_services.READ,
		"MANAGER", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	q := queries.NewUsersForHiringQuery(
		input.ID,
		input.Query,
		input.Limit,
		input.Offset,
	)
	users, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.User, 0, len(users.Users))
	for _, v := range users.Users {
		results = append(results, &model.User{
			UserName: v.Username,
			Person: &model.Person{
				ProfileImg:  v.Person.ProfileImg,
				Email:       v.Person.Email,
				FirstName:   v.Person.FirstName,
				LastName:    v.Person.LastName,
				Genre:       v.Person.Genre,
				Pronoun:     v.Person.Pronoun,
				Age:         v.Person.Age,
				PhoneNumber: v.Person.Phone,
				Address: &model.Address{
					Country:      v.Person.Address.Country,
					CountryState: v.Person.Address.County,
					City:         v.Person.Address.City,
				},
			},
			Status: model.UserStatusOffline,
		})
	}
	return &model.UsersForHiringResult{
		Users:      results,
		Count:      users.Count,
		Limit:      users.CurrentLimit,
		Offset:     users.CurrentOffset,
		NextCursor: users.NextCursor,
		PrevCursor: users.NextCursor - 1,
	}, nil
}

// UserByID is the resolver for the userById field.
func (r *queryResolver) UserByID(ctx context.Context, id string) (*model.User, error) {
	q := queries.NewUserByIdQuery(id)
	user, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.User{
		UserName: user.Username,
		Person: &model.Person{
			ProfileImg:  user.Person.ProfileImg,
			Email:       user.Person.Email,
			FirstName:   user.Person.FirstName,
			LastName:    user.Person.LastName,
			Genre:       user.Person.Genre,
			Pronoun:     user.Person.Pronoun,
			Age:         user.Person.Age,
			PhoneNumber: user.Person.Phone,
			Address: &model.Address{
				Country:      user.Person.Address.Country,
				CountryState: user.Person.Address.County,
				City:         user.Person.Address.City,
			},
		},
		Status: model.UserStatusOffline,
	}, nil
}

// HiringInvitationsByAuthenticatedUser is the resolver for the hiringInvitationsByAuthenticatedUser field.
func (r *queryResolver) HiringInvitationsByAuthenticatedUser(ctx context.Context) ([]*model.HiringInvitation, error) {
	panic(fmt.Errorf("not implemented: HiringInvitationsByAuthenticatedUser - hiringInvitationsByAuthenticatedUser"))
}

// Notifications is the resolver for the notifications field.
func (r *subscriptionResolver) Notifications(ctx context.Context, id string) (<-chan *model.Notification, error) {
	q := queries.NewNotificationsByOwnerIdQuery(id)
	stored, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	toModel := make([]*model.Notification, 0, len(stored))
	for _, n := range stored {
		toModel = append(toModel, &model.Notification{
			ID: n.Id,
			Owner: &model.Recipient{
				ID:               n.Owner.Id,
				SubjectName:      &n.Owner.SubjectName,
				SubjectThumbnail: &n.Owner.SubjectThumbnail,
				IsEnterprise:     &n.Owner.IsEnterprise,
			},
			Sender: &model.Recipient{
				ID:               n.Sender.Id,
				SubjectName:      &n.Sender.SubjectName,
				SubjectThumbnail: &n.Sender.SubjectThumbnail,
				IsEnterprise:     &n.Sender.IsEnterprise,
			},
			Title:      n.Title,
			Content:    n.Content,
			Link:       n.Link,
			Seen:       n.Seen,
			OccurredOn: n.OccurredOn,
		})
	}
	in := make(chan application.ApplicationMessage)
	r.Publisher.Subscribe(&application.Subscriber{
		Id:   id,
		Send: in,
	})
	ch := make(chan *model.Notification)
	go func() {
		defer func() {
			r.Publisher.Unsubscribe(id)
			close(ch)
		}()
		for i := range toModel {
			ch <- toModel[i]
		}
		for {
			select {
			case <-ctx.Done():
				return
			case m := <-in:
				if m.DataType() == "notification" {
					n, ok := m.Value().(dto.Notification)
					if ok {
						ch <- &model.Notification{
							ID: n.Id,
							Owner: &model.Recipient{
								ID:               n.Owner.Id,
								SubjectName:      &n.Owner.SubjectName,
								SubjectThumbnail: &n.Owner.SubjectThumbnail,
								IsEnterprise:     &n.Owner.IsEnterprise,
							},
							Sender: &model.Recipient{
								ID:               n.Sender.Id,
								SubjectName:      &n.Sender.SubjectName,
								SubjectThumbnail: &n.Sender.SubjectThumbnail,
								IsEnterprise:     &n.Sender.IsEnterprise,
							},
							Title:      n.Title,
							Content:    n.Content,
							Link:       n.Link,
							Seen:       n.Seen,
							OccurredOn: n.OccurredOn,
						}
					}
				}
			}
		}
	}()
	return ch, nil
}

// Complaints is the resolver for the complaints field.
func (r *subscriptionResolver) Complaints(ctx context.Context, id string) (<-chan *model.Complaint, error) {
	q := queries.NewComplaintsByAuthorOrReceiverIdQuery(id)
	stored, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	toModel := make([]*model.Complaint, 0)
	for _, v := range stored {
		replies := make([]*model.ComplaintReply, 0, len(v.Replies))
		for _, r := range v.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          r.Id,
				ComplaintID: r.ComplaintId,
				Sender: &model.Recipient{
					ID:               r.Sender.Id,
					SubjectName:      &r.Sender.SubjectName,
					SubjectThumbnail: &r.Sender.SubjectThumbnail,
					IsEnterprise:     &r.Sender.IsEnterprise,
					IsOnline:         r.Sender.IsOnline,
				},
				Body:      r.Body,
				CreatedAt: r.CreatedAt,
				Read:      &r.Read,
				ReadAt:    r.ReadAt,
				UpdatedAt: r.UpdatedAt,
			})
		}
		toModel = append(toModel, &model.Complaint{
			ID: v.Id,
			Author: &model.Recipient{
				ID:               v.Author.Id,
				SubjectName:      &v.Author.SubjectName,
				SubjectThumbnail: &v.Author.SubjectThumbnail,
				IsEnterprise:     &v.Author.IsEnterprise,
				IsOnline:         v.Author.IsOnline,
			},
			Receiver: &model.Recipient{
				ID:               v.Receiver.Id,
				SubjectName:      &v.Receiver.SubjectName,
				SubjectThumbnail: &v.Receiver.SubjectThumbnail,
				IsEnterprise:     &v.Receiver.IsEnterprise,
				IsOnline:         v.Receiver.IsOnline,
			},
			Status:      model.ComplaintStatus(v.Status),
			Title:       v.Title,
			Description: v.Description,
			Rating: &model.Rating{
				ID:      v.Rating.Id,
				Rate:    v.Rating.Rate,
				Comment: v.Rating.Comment,
			},
			CreatedAt: v.CreatedAt,
			UpdatedAt: v.UpdatedAt,
			Replies:   replies,
		})
	}
	in := make(chan application.ApplicationMessage)
	r.Publisher.Subscribe(&application.Subscriber{
		Id:   id,
		Send: in,
	})
	ch := make(chan *model.Complaint)
	go func() {
		defer func() {
			r.Publisher.Unsubscribe(id)
			close(ch)
		}()
		for _, v := range toModel {
			//log.Printf("stored author %s=%v  \n stored receiver %s=%v \n", v.Author.ID, v.Author.IsOnline, v.Receiver.ID, v.Author.IsOnline)
			ch <- v
		}
		for {
			select {
			case <-ctx.Done():
				return
			case m := <-in:
				if m.DataType() == "subscriber_connected" {
					//log.Printf("sub conn subs: %v", r.Publisher.ApplicationSubscribers())
					for _, v := range toModel {
						if v.Author.ID == m.Value() {
							//log.Printf("conn author %s match %s prev %v", v.Author.ID, m.Value(), v.Author.IsOnline)
							r.mu.Lock()
							v.Author.IsOnline = true
							r.mu.Unlock()
							ch <- v
						}
						if v.Receiver.ID == m.Value() {
							//log.Printf("conn receiver %s match %s prev %v", v.Receiver.ID, m.Value(), v.Receiver.IsOnline)
							r.mu.Lock()
							v.Receiver.IsOnline = true
							r.mu.Unlock()
							ch <- v
						}
					}

				}
				if m.DataType() == "subscriber_disconnected" {
					log.Printf("sub disconn subs: %v", r.Publisher.ApplicationSubscribers())
					for _, v := range toModel {
						if v.Author.ID == m.Value() {
							r.mu.Lock()
							v.Author.IsOnline = false
							r.mu.Unlock()
							ch <- v
						}
						if v.Receiver.ID == m.Value() {
							r.mu.Lock()
							v.Receiver.IsOnline = false
							r.mu.Unlock()
							ch <- v
						}
					}
				}
				if m.DataType() == "complaint" {
					v, ok := m.Value().(dto.Complaint)
					if ok {
						replies := make([]*model.ComplaintReply, 0, len(v.Replies))
						for _, r := range v.Replies {
							replies = append(replies, &model.ComplaintReply{
								ID:          r.Id,
								ComplaintID: r.ComplaintId,
								Sender: &model.Recipient{
									ID:               r.Sender.Id,
									SubjectName:      &r.Sender.SubjectName,
									SubjectThumbnail: &r.Sender.SubjectThumbnail,
									IsEnterprise:     &r.Sender.IsEnterprise,
									IsOnline:         r.Sender.IsOnline,
								},
								Body:      r.Body,
								CreatedAt: r.CreatedAt,
								Read:      &r.Read,
								ReadAt:    r.ReadAt,
								UpdatedAt: r.UpdatedAt,
							})
						}
						casted := &model.Complaint{
							ID: v.Id,
							Author: &model.Recipient{
								ID:               v.Author.Id,
								SubjectName:      &v.Author.SubjectName,
								SubjectThumbnail: &v.Author.SubjectThumbnail,
								IsEnterprise:     &v.Author.IsEnterprise,
								IsOnline:         v.Author.IsOnline,
							},
							Receiver: &model.Recipient{
								ID:               v.Receiver.Id,
								SubjectName:      &v.Receiver.SubjectName,
								SubjectThumbnail: &v.Receiver.SubjectThumbnail,
								IsEnterprise:     &v.Receiver.IsEnterprise,
								IsOnline:         v.Receiver.IsOnline,
							},
							Status:      model.ComplaintStatus(v.Status),
							Title:       v.Title,
							Description: v.Description,
							Rating: &model.Rating{
								ID:      v.Rating.Id,
								Rate:    v.Rating.Rate,
								Comment: v.Rating.Comment,
							},
							CreatedAt: v.CreatedAt,
							UpdatedAt: v.UpdatedAt,
							Replies:   replies,
						}
						toModel = append(toModel, casted)
						ch <- casted
					}
				}
			}
		}
	}()
	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
