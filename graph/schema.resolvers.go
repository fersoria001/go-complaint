package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"go-complaint/application"
	"go-complaint/application/application_services"
	"go-complaint/application/commands"
	"go-complaint/application/queries"
	"go-complaint/chat"
	"go-complaint/dto"
	"go-complaint/graph/model"
	"log"
	"slices"

	"github.com/99designs/gqlgen/graphql"
	pgx "github.com/jackc/pgx/v5"
)

// ContactEmail is the resolver for the contactEmail field.
func (r *mutationResolver) ContactEmail(ctx context.Context, input model.ContactEmail) (bool, error) {
	c := commands.SendContactEmailCommand{
		From:    input.From,
		Message: *input.Message,
	}
	err := c.Execute(ctx)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUser) (*model.User, error) {
	c := commands.NewRegisterUserCommand(
		input.UserName,
		input.Password,
		input.FirstName,
		input.LastName,
		input.Genre,
		input.Pronoun,
		input.BirthDate,
		input.PhoneNumber,
		"/default.jpg",
		input.CountryID,
		input.CityID,
		input.CountryStateID,
	)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewUserByUsernameQuery(input.UserName)
	user, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:       user.Id,
		UserName: user.Username,
		Person: &model.Person{
			ProfileImg:  user.Person.ProfileImg,
			Email:       user.Person.Email,
			FirstName:   user.Person.FirstName,
			LastName:    user.Person.LastName,
			Genre:       user.Person.Genre,
			Pronoun:     user.Person.Pronoun,
			Age:         user.Person.Age,
			PhoneNumber: user.Person.Phone,
			Address: &model.Address{
				Country:      user.Person.Address.Country,
				CountryState: user.Person.Address.County,
				City:         user.Person.Address.City,
			},
		},
		Status: model.UserStatusOffline,
	}, nil
}

// RecoverPassword is the resolver for the recoverPassword field.
func (r *mutationResolver) RecoverPassword(ctx context.Context, userName string) (bool, error) {
	c := commands.NewRecoverPasswordCommand(userName)
	err := c.Execute(ctx)
	if err != nil {
		return false, err
	}
	return true, nil
}

// UpdateProfileImg is the resolver for the updateProfileImg field.
func (r *mutationResolver) UpdateProfileImg(ctx context.Context, id string, file graphql.Upload) (*model.User, error) {
	c := commands.NewChangeProfileImageCommand(id, file.Filename, file.File)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewUserByIdQuery(id)
	user, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:       user.Id,
		UserName: user.Username,
		Person: &model.Person{
			ProfileImg:  user.Person.ProfileImg,
			Email:       user.Person.Email,
			FirstName:   user.Person.FirstName,
			LastName:    user.Person.LastName,
			Genre:       user.Person.Genre,
			Pronoun:     user.Person.Pronoun,
			Age:         user.Person.Age,
			PhoneNumber: user.Person.Phone,
			Address: &model.Address{
				Country:      user.Person.Address.Country,
				CountryState: user.Person.Address.County,
				City:         user.Person.Address.City,
			},
		},
		Status: model.UserStatusOffline,
	}, nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, input model.ChangePassword) (*model.User, error) {
	c := commands.NewChangePasswordCommand(input.Username, input.OldPassword, input.NewPassword)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewUserByUsernameQuery(input.Username)
	user, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:       user.Id,
		UserName: user.Username,
		Person: &model.Person{
			ProfileImg:  user.Person.ProfileImg,
			Email:       user.Person.Email,
			FirstName:   user.Person.FirstName,
			LastName:    user.Person.LastName,
			Genre:       user.Person.Genre,
			Pronoun:     user.Person.Pronoun,
			Age:         user.Person.Age,
			PhoneNumber: user.Person.Phone,
			Address: &model.Address{
				Country:      user.Person.Address.Country,
				CountryState: user.Person.Address.County,
				City:         user.Person.Address.City,
			},
		},
		Status: model.UserStatusOffline,
	}, nil
}

// ChangeUserGenre is the resolver for the changeUserGenre field.
func (r *mutationResolver) ChangeUserGenre(ctx context.Context, input model.ChangeUserGenre) (*model.User, error) {
	c := commands.NewChangeUserGenreCommand(input.UserID, input.NewGenre)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewUserByIdQuery(input.UserID)
	user, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:       user.Id,
		UserName: user.Username,
		Person: &model.Person{
			ProfileImg:  user.Person.ProfileImg,
			Email:       user.Person.Email,
			FirstName:   user.Person.FirstName,
			LastName:    user.Person.LastName,
			Genre:       user.Person.Genre,
			Pronoun:     user.Person.Pronoun,
			Age:         user.Person.Age,
			PhoneNumber: user.Person.Phone,
			Address: &model.Address{
				Country:      user.Person.Address.Country,
				CountryState: user.Person.Address.County,
				City:         user.Person.Address.City,
			},
		},
		Status: model.UserStatusOffline,
	}, nil
}

// ChangeUserPronoun is the resolver for the ChangeUserPronoun field.
func (r *mutationResolver) ChangeUserPronoun(ctx context.Context, input model.ChangeUserPronoun) (*model.User, error) {
	c := commands.NewChangeUserPronounCommand(input.UserID, input.NewPronoun)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewUserByIdQuery(input.UserID)
	user, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:       user.Id,
		UserName: user.Username,
		Person: &model.Person{
			ProfileImg:  user.Person.ProfileImg,
			Email:       user.Person.Email,
			FirstName:   user.Person.FirstName,
			LastName:    user.Person.LastName,
			Genre:       user.Person.Genre,
			Pronoun:     user.Person.Pronoun,
			Age:         user.Person.Age,
			PhoneNumber: user.Person.Phone,
			Address: &model.Address{
				Country:      user.Person.Address.Country,
				CountryState: user.Person.Address.County,
				City:         user.Person.Address.City,
			},
		},
		Status: model.UserStatusOffline,
	}, nil
}

// ChangeFirstName is the resolver for the changeFirstName field.
func (r *mutationResolver) ChangeFirstName(ctx context.Context, input model.ChangeUserFirstName) (*model.User, error) {
	c := commands.NewChangeUserFirstNameCommand(input.UserID, input.NewFirstName)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewUserByIdQuery(input.UserID)
	user, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:       user.Id,
		UserName: user.Username,
		Person: &model.Person{
			ProfileImg:  user.Person.ProfileImg,
			Email:       user.Person.Email,
			FirstName:   user.Person.FirstName,
			LastName:    user.Person.LastName,
			Genre:       user.Person.Genre,
			Pronoun:     user.Person.Pronoun,
			Age:         user.Person.Age,
			PhoneNumber: user.Person.Phone,
			Address: &model.Address{
				Country:      user.Person.Address.Country,
				CountryState: user.Person.Address.County,
				City:         user.Person.Address.City,
			},
		},
		Status: model.UserStatusOffline,
	}, nil
}

// ChangeLastName is the resolver for the changeLastName field.
func (r *mutationResolver) ChangeLastName(ctx context.Context, input model.ChangeUserLastName) (*model.User, error) {
	c := commands.NewChangeUserLastNameCommand(input.UserID, input.NewLastName)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewUserByIdQuery(input.UserID)
	user, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:       user.Id,
		UserName: user.Username,
		Person: &model.Person{
			ProfileImg:  user.Person.ProfileImg,
			Email:       user.Person.Email,
			FirstName:   user.Person.FirstName,
			LastName:    user.Person.LastName,
			Genre:       user.Person.Genre,
			Pronoun:     user.Person.Pronoun,
			Age:         user.Person.Age,
			PhoneNumber: user.Person.Phone,
			Address: &model.Address{
				Country:      user.Person.Address.Country,
				CountryState: user.Person.Address.County,
				City:         user.Person.Address.City,
			},
		},
		Status: model.UserStatusOffline,
	}, nil
}

// ChangeUserPhone is the resolver for the changeUserPhone field.
func (r *mutationResolver) ChangeUserPhone(ctx context.Context, input model.ChangeUserPhone) (*model.User, error) {
	c := commands.NewChangeUserPhoneCommand(input.UserID, input.NewPhone)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewUserByIdQuery(input.UserID)
	user, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:       user.Id,
		UserName: user.Username,
		Person: &model.Person{
			ProfileImg:  user.Person.ProfileImg,
			Email:       user.Person.Email,
			FirstName:   user.Person.FirstName,
			LastName:    user.Person.LastName,
			Genre:       user.Person.Genre,
			Pronoun:     user.Person.Pronoun,
			Age:         user.Person.Age,
			PhoneNumber: user.Person.Phone,
			Address: &model.Address{
				Country:      user.Person.Address.Country,
				CountryState: user.Person.Address.County,
				City:         user.Person.Address.City,
			},
		},
		Status: model.UserStatusOffline,
	}, nil
}

// UpdateUserAddress is the resolver for the updateUserAddress field.
func (r *mutationResolver) UpdateUserAddress(ctx context.Context, input model.UpdateUserAddress) (*model.User, error) {
	c := commands.NewChangeUserAddressCommand(input.UserID, input.NewCountryID, input.NewCountyID, input.NewCityID)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewUserByIdQuery(input.UserID)
	user, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:       user.Id,
		UserName: user.Username,
		Person: &model.Person{
			ProfileImg:  user.Person.ProfileImg,
			Email:       user.Person.Email,
			FirstName:   user.Person.FirstName,
			LastName:    user.Person.LastName,
			Genre:       user.Person.Genre,
			Pronoun:     user.Person.Pronoun,
			Age:         user.Person.Age,
			PhoneNumber: user.Person.Phone,
			Address: &model.Address{
				Country:      user.Person.Address.Country,
				CountryState: user.Person.Address.County,
				City:         user.Person.Address.City,
			},
		},
		Status: model.UserStatusOffline,
	}, nil
}

// CreateEnterprise is the resolver for the createEnterprise field.
func (r *mutationResolver) CreateEnterprise(ctx context.Context, input model.CreateEnterprise) (*model.Enterprise, error) {
	currentUser, err := application_services.AuthorizationApplicationServiceInstance().Credentials(ctx)
	if err != nil {
		return nil, err
	}
	c := commands.NewRegisterEnterpriseCommand(
		currentUser.Id,
		input.Name,
		"/default.jpg",
		"/banner.jpg",
		input.Website,
		input.Email,
		input.PhoneNumber,
		input.FoundationDate,
		input.IndustryID,
		input.CountryID,
		input.CountryStateID,
		input.CityID,
	)
	err = c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewEnterpriseByNameQuery(input.Name)
	enterprise, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	employees := make([]*model.Employee, 0, len(enterprise.Employees))
	for _, v := range enterprise.Employees {
		employees = append(employees, &model.Employee{
			ID:           v.ID.String(),
			EnterpriseID: v.EnterpriseID,
			UserID:       v.UserID,
			User: &model.User{
				ID:       v.UserID,
				UserName: v.Email,
				Person: &model.Person{
					ProfileImg:  v.ProfileIMG,
					Email:       v.Email,
					FirstName:   v.FirstName,
					LastName:    v.LastName,
					Genre:       "",
					Pronoun:     "",
					Age:         v.Age,
					PhoneNumber: v.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         v.HiringDate,
			ApprovedHiring:     v.ApprovedHiring,
			ApprovedHiringAt:   v.ApprovedHiringAt,
			EnterprisePosition: v.Position,
		})
	}
	return &model.Enterprise{
		Name:        enterprise.Name,
		LogoImg:     enterprise.LogoIMG,
		BannerImg:   enterprise.BannerIMG,
		Website:     enterprise.Website,
		Email:       enterprise.Email,
		PhoneNumber: enterprise.Phone,
		Address: &model.Address{
			Country:      enterprise.Address.Country,
			CountryState: enterprise.Address.County,
			City:         enterprise.Address.City,
		},
		Industry: &model.Industry{
			ID:   enterprise.Industry.ID,
			Name: enterprise.Industry.Name,
		},
		FoundationDate: enterprise.FoundationDate,
		OwnerID:        enterprise.OwnerID,
		Employees:      employees,
	}, nil
}

// ChangeEnterpriseBannerImg is the resolver for the changeEnterpriseBannerImg field.
func (r *mutationResolver) ChangeEnterpriseBannerImg(ctx context.Context, enterpriseID string, file graphql.Upload) (*model.Enterprise, error) {
	c := commands.NewChangeBannerImageCommand(enterpriseID, file.Filename, file.File)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewEnterpriseByIdQuery(enterpriseID)
	enterprise, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	employees := make([]*model.Employee, 0, len(enterprise.Employees))
	for _, v := range enterprise.Employees {
		employees = append(employees, &model.Employee{
			ID:           v.ID.String(),
			EnterpriseID: v.EnterpriseID,
			UserID:       v.UserID,
			User: &model.User{
				ID:       v.UserID,
				UserName: v.Email,
				Person: &model.Person{
					ProfileImg:  v.ProfileIMG,
					Email:       v.Email,
					FirstName:   v.FirstName,
					LastName:    v.LastName,
					Genre:       "",
					Pronoun:     "",
					Age:         v.Age,
					PhoneNumber: v.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         v.HiringDate,
			ApprovedHiring:     v.ApprovedHiring,
			ApprovedHiringAt:   v.ApprovedHiringAt,
			EnterprisePosition: v.Position,
		})
	}
	return &model.Enterprise{
		Name:        enterprise.Name,
		LogoImg:     enterprise.LogoIMG,
		BannerImg:   enterprise.BannerIMG,
		Website:     enterprise.Website,
		Email:       enterprise.Email,
		PhoneNumber: enterprise.Phone,
		Address: &model.Address{
			Country:      enterprise.Address.Country,
			CountryState: enterprise.Address.County,
			City:         enterprise.Address.City,
		},
		Industry: &model.Industry{
			ID:   enterprise.Industry.ID,
			Name: enterprise.Industry.Name,
		},
		FoundationDate: enterprise.FoundationDate,
		OwnerID:        enterprise.OwnerID,
		Employees:      employees,
	}, nil
}

// ChangeEnterpriseLogoImg is the resolver for the changeEnterpriseLogoImg field.
func (r *mutationResolver) ChangeEnterpriseLogoImg(ctx context.Context, enterpriseID string, file graphql.Upload) (*model.Enterprise, error) {
	c := commands.NewChangeLogoImageCommand(enterpriseID, file.Filename, file.File)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewEnterpriseByIdQuery(enterpriseID)
	enterprise, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	employees := make([]*model.Employee, 0, len(enterprise.Employees))
	for _, v := range enterprise.Employees {
		employees = append(employees, &model.Employee{
			ID:           v.ID.String(),
			EnterpriseID: v.EnterpriseID,
			UserID:       v.UserID,
			User: &model.User{
				ID:       v.UserID,
				UserName: v.Email,
				Person: &model.Person{
					ProfileImg:  v.ProfileIMG,
					Email:       v.Email,
					FirstName:   v.FirstName,
					LastName:    v.LastName,
					Genre:       "",
					Pronoun:     "",
					Age:         v.Age,
					PhoneNumber: v.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         v.HiringDate,
			ApprovedHiring:     v.ApprovedHiring,
			ApprovedHiringAt:   v.ApprovedHiringAt,
			EnterprisePosition: v.Position,
		})
	}
	return &model.Enterprise{
		Name:        enterprise.Name,
		LogoImg:     enterprise.LogoIMG,
		BannerImg:   enterprise.BannerIMG,
		Website:     enterprise.Website,
		Email:       enterprise.Email,
		PhoneNumber: enterprise.Phone,
		Address: &model.Address{
			Country:      enterprise.Address.Country,
			CountryState: enterprise.Address.County,
			City:         enterprise.Address.City,
		},
		Industry: &model.Industry{
			ID:   enterprise.Industry.ID,
			Name: enterprise.Industry.Name,
		},
		FoundationDate: enterprise.FoundationDate,
		OwnerID:        enterprise.OwnerID,
		Employees:      employees,
	}, nil
}

// ChangeEnterpriseWebsite is the resolver for the changeEnterpriseWebsite field.
func (r *mutationResolver) ChangeEnterpriseWebsite(ctx context.Context, input model.ChangeEnterpriseWebsite) (*model.Enterprise, error) {
	c := commands.NewChangeEnterpriseWebsiteCommand(input.EnterpriseID, input.NewWebsite)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewEnterpriseByIdQuery(input.EnterpriseID)
	enterprise, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	employees := make([]*model.Employee, 0, len(enterprise.Employees))
	for _, v := range enterprise.Employees {
		employees = append(employees, &model.Employee{
			ID:           v.ID.String(),
			EnterpriseID: v.EnterpriseID,
			UserID:       v.UserID,
			User: &model.User{
				ID:       v.UserID,
				UserName: v.Email,
				Person: &model.Person{
					ProfileImg:  v.ProfileIMG,
					Email:       v.Email,
					FirstName:   v.FirstName,
					LastName:    v.LastName,
					Genre:       "",
					Pronoun:     "",
					Age:         v.Age,
					PhoneNumber: v.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         v.HiringDate,
			ApprovedHiring:     v.ApprovedHiring,
			ApprovedHiringAt:   v.ApprovedHiringAt,
			EnterprisePosition: v.Position,
		})
	}
	return &model.Enterprise{
		Name:        enterprise.Name,
		LogoImg:     enterprise.LogoIMG,
		BannerImg:   enterprise.BannerIMG,
		Website:     enterprise.Website,
		Email:       enterprise.Email,
		PhoneNumber: enterprise.Phone,
		Address: &model.Address{
			Country:      enterprise.Address.Country,
			CountryState: enterprise.Address.County,
			City:         enterprise.Address.City,
		},
		Industry: &model.Industry{
			ID:   enterprise.Industry.ID,
			Name: enterprise.Industry.Name,
		},
		FoundationDate: enterprise.FoundationDate,
		OwnerID:        enterprise.OwnerID,
		Employees:      employees,
	}, nil
}

// ChangeEnterpriseEmail is the resolver for the changeEnterpriseEmail field.
func (r *mutationResolver) ChangeEnterpriseEmail(ctx context.Context, input model.ChangeEnterpriseEmail) (*model.Enterprise, error) {
	c := commands.NewChangeEnterpriseEmailCommand(input.EnterpriseID, input.NewEmail)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewEnterpriseByIdQuery(input.EnterpriseID)
	enterprise, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	employees := make([]*model.Employee, 0, len(enterprise.Employees))
	for _, v := range enterprise.Employees {
		employees = append(employees, &model.Employee{
			ID:           v.ID.String(),
			EnterpriseID: v.EnterpriseID,
			UserID:       v.UserID,
			User: &model.User{
				ID:       v.UserID,
				UserName: v.Email,
				Person: &model.Person{
					ProfileImg:  v.ProfileIMG,
					Email:       v.Email,
					FirstName:   v.FirstName,
					LastName:    v.LastName,
					Genre:       "",
					Pronoun:     "",
					Age:         v.Age,
					PhoneNumber: v.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         v.HiringDate,
			ApprovedHiring:     v.ApprovedHiring,
			ApprovedHiringAt:   v.ApprovedHiringAt,
			EnterprisePosition: v.Position,
		})
	}
	return &model.Enterprise{
		Name:        enterprise.Name,
		LogoImg:     enterprise.LogoIMG,
		BannerImg:   enterprise.BannerIMG,
		Website:     enterprise.Website,
		Email:       enterprise.Email,
		PhoneNumber: enterprise.Phone,
		Address: &model.Address{
			Country:      enterprise.Address.Country,
			CountryState: enterprise.Address.County,
			City:         enterprise.Address.City,
		},
		Industry: &model.Industry{
			ID:   enterprise.Industry.ID,
			Name: enterprise.Industry.Name,
		},
		FoundationDate: enterprise.FoundationDate,
		OwnerID:        enterprise.OwnerID,
		Employees:      employees,
	}, nil
}

// ChangeEnterprisePhone is the resolver for the changeEnterprisePhone field.
func (r *mutationResolver) ChangeEnterprisePhone(ctx context.Context, input model.ChangeEnterprisePhone) (*model.Enterprise, error) {
	c := commands.NewChangeEnterprisePhoneCommand(input.EnterpriseID, input.NewPhone)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewEnterpriseByIdQuery(input.EnterpriseID)
	enterprise, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	employees := make([]*model.Employee, 0, len(enterprise.Employees))
	for _, v := range enterprise.Employees {
		employees = append(employees, &model.Employee{
			ID:           v.ID.String(),
			EnterpriseID: v.EnterpriseID,
			UserID:       v.UserID,
			User: &model.User{
				ID:       v.UserID,
				UserName: v.Email,
				Person: &model.Person{
					ProfileImg:  v.ProfileIMG,
					Email:       v.Email,
					FirstName:   v.FirstName,
					LastName:    v.LastName,
					Genre:       "",
					Pronoun:     "",
					Age:         v.Age,
					PhoneNumber: v.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         v.HiringDate,
			ApprovedHiring:     v.ApprovedHiring,
			ApprovedHiringAt:   v.ApprovedHiringAt,
			EnterprisePosition: v.Position,
		})
	}
	return &model.Enterprise{
		Name:        enterprise.Name,
		LogoImg:     enterprise.LogoIMG,
		BannerImg:   enterprise.BannerIMG,
		Website:     enterprise.Website,
		Email:       enterprise.Email,
		PhoneNumber: enterprise.Phone,
		Address: &model.Address{
			Country:      enterprise.Address.Country,
			CountryState: enterprise.Address.County,
			City:         enterprise.Address.City,
		},
		Industry: &model.Industry{
			ID:   enterprise.Industry.ID,
			Name: enterprise.Industry.Name,
		},
		FoundationDate: enterprise.FoundationDate,
		OwnerID:        enterprise.OwnerID,
		Employees:      employees,
	}, nil
}

// ChangeEnterpriseAddress is the resolver for the changeEnterpriseAddress field.
func (r *mutationResolver) ChangeEnterpriseAddress(ctx context.Context, input model.ChangeEnterpriseAddress) (*model.Enterprise, error) {
	c := commands.NewChangeEnterpriseAddressCommand(input.EnterpriseID, input.NewCountryID, input.NewCountyID, input.NewCityID)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewEnterpriseByIdQuery(input.EnterpriseID)
	enterprise, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	employees := make([]*model.Employee, 0, len(enterprise.Employees))
	for _, v := range enterprise.Employees {
		employees = append(employees, &model.Employee{
			ID:           v.ID.String(),
			EnterpriseID: v.EnterpriseID,
			UserID:       v.UserID,
			User: &model.User{
				ID:       v.UserID,
				UserName: v.Email,
				Person: &model.Person{
					ProfileImg:  v.ProfileIMG,
					Email:       v.Email,
					FirstName:   v.FirstName,
					LastName:    v.LastName,
					Genre:       "",
					Pronoun:     "",
					Age:         v.Age,
					PhoneNumber: v.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         v.HiringDate,
			ApprovedHiring:     v.ApprovedHiring,
			ApprovedHiringAt:   v.ApprovedHiringAt,
			EnterprisePosition: v.Position,
		})
	}
	return &model.Enterprise{
		Name:        enterprise.Name,
		LogoImg:     enterprise.LogoIMG,
		BannerImg:   enterprise.BannerIMG,
		Website:     enterprise.Website,
		Email:       enterprise.Email,
		PhoneNumber: enterprise.Phone,
		Address: &model.Address{
			Country:      enterprise.Address.Country,
			CountryState: enterprise.Address.County,
			City:         enterprise.Address.City,
		},
		Industry: &model.Industry{
			ID:   enterprise.Industry.ID,
			Name: enterprise.Industry.Name,
		},
		FoundationDate: enterprise.FoundationDate,
		OwnerID:        enterprise.OwnerID,
		Employees:      employees,
	}, nil
}

// InviteToProject is the resolver for the inviteToProject field.
func (r *mutationResolver) InviteToProject(ctx context.Context, input model.InviteToProject) (*model.HiringProcess, error) {
	c := commands.NewInviteToProjectCommand(input.EnterpriseID, input.Role, input.ProposeTo, input.ProposedBy)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewHiringProcessByEnterpriseNameAndProposedToQuery(input.ProposeTo, input.EnterpriseID)
	dbh, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.HiringProcess{
		ID: dbh.Id,
		Enterprise: &model.Recipient{
			ID:               &dbh.Enterprise.Id,
			SubjectName:      &dbh.Enterprise.SubjectName,
			SubjectThumbnail: &dbh.Enterprise.SubjectThumbnail,
			SubjectEmail:     &dbh.Enterprise.SubjectEmail,
		},
		User: &model.User{
			ID:       dbh.User.Id,
			UserName: dbh.User.Username,
			Person: &model.Person{
				ProfileImg:  dbh.User.Person.ProfileImg,
				Email:       dbh.User.Person.Email,
				FirstName:   dbh.User.Person.FirstName,
				LastName:    dbh.User.Person.LastName,
				Genre:       dbh.User.Person.Genre,
				Pronoun:     dbh.User.Person.Pronoun,
				Age:         dbh.User.Person.Age,
				PhoneNumber: dbh.User.Person.Phone,
				Address: &model.Address{
					Country:      dbh.User.Person.Address.Country,
					CountryState: dbh.User.Person.Address.County,
					City:         dbh.User.Person.Address.City,
				},
			},
			Status: model.UserStatusOffline,
		},
		Role:   dbh.Role,
		Status: (*model.HiringProccessStatus)(&dbh.Status),
		Reason: &dbh.Reason,
		EmitedBy: &model.Recipient{
			ID:               &dbh.EmitedBy.Id,
			SubjectName:      &dbh.EmitedBy.SubjectName,
			SubjectThumbnail: &dbh.EmitedBy.SubjectThumbnail,
			SubjectEmail:     &dbh.EmitedBy.SubjectThumbnail,
		},
		OccurredOn: dbh.OccurredOn,
		LastUpdate: dbh.LastUpdate,
		UpdatedBy: &model.Recipient{
			ID:               &dbh.UpdatedBy.Id,
			SubjectName:      &dbh.UpdatedBy.SubjectName,
			SubjectThumbnail: &dbh.UpdatedBy.SubjectThumbnail,
			SubjectEmail:     &dbh.UpdatedBy.SubjectThumbnail,
		},
	}, nil
}

// MarkNotificationAsRead is the resolver for the markNotificationAsRead field.
func (r *mutationResolver) MarkNotificationAsRead(ctx context.Context, id string) (*model.NotificationLink, error) {
	c := commands.NewMarkNotificationAsReadCommand(id)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewNotificationByIdQuery(id)
	n, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.NotificationLink{
		ID: n.Id,
		Owner: &model.Recipient{
			ID:               &n.Owner.Id,
			SubjectName:      &n.Owner.SubjectName,
			SubjectThumbnail: &n.Owner.SubjectThumbnail,
			IsEnterprise:     &n.Owner.IsEnterprise,
		},
		Sender: &model.Recipient{
			ID:               &n.Sender.Id,
			SubjectName:      &n.Sender.SubjectName,
			SubjectThumbnail: &n.Sender.SubjectThumbnail,
			IsEnterprise:     &n.Sender.IsEnterprise,
		},
		Title:      n.Title,
		Content:    n.Content,
		Link:       n.Link,
		Seen:       n.Seen,
		OccurredOn: n.OccurredOn,
	}, nil
}

// AcceptHiringInvitation is the resolver for the acceptHiringInvitation field.
func (r *mutationResolver) AcceptHiringInvitation(ctx context.Context, input model.AcceptHiringInvitation) (*model.HiringProcess, error) {
	c := commands.NewAcceptHiringInvitationCommand(input.UserID, input.HiringProcessID)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewHiringProcessByIdQuery(input.HiringProcessID)
	dbh, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.HiringProcess{
		ID: dbh.Id,
		Enterprise: &model.Recipient{
			ID:               &dbh.Enterprise.Id,
			SubjectName:      &dbh.Enterprise.SubjectName,
			SubjectThumbnail: &dbh.Enterprise.SubjectThumbnail,
			SubjectEmail:     &dbh.Enterprise.SubjectEmail,
		},
		User: &model.User{
			ID:       dbh.User.Id,
			UserName: dbh.User.Username,
			Person: &model.Person{
				ProfileImg:  dbh.User.Person.ProfileImg,
				Email:       dbh.User.Person.Email,
				FirstName:   dbh.User.Person.FirstName,
				LastName:    dbh.User.Person.LastName,
				Genre:       dbh.User.Person.Genre,
				Pronoun:     dbh.User.Person.Pronoun,
				Age:         dbh.User.Person.Age,
				PhoneNumber: dbh.User.Person.Phone,
				Address: &model.Address{
					Country:      dbh.User.Person.Address.Country,
					CountryState: dbh.User.Person.Address.County,
					City:         dbh.User.Person.Address.City,
				},
			},
			Status: model.UserStatusOffline,
		},
		Role:   dbh.Role,
		Status: (*model.HiringProccessStatus)(&dbh.Status),
		Reason: &dbh.Reason,
		EmitedBy: &model.Recipient{
			ID:               &dbh.EmitedBy.Id,
			SubjectName:      &dbh.EmitedBy.SubjectName,
			SubjectThumbnail: &dbh.EmitedBy.SubjectThumbnail,
			SubjectEmail:     &dbh.EmitedBy.SubjectThumbnail,
		},
		OccurredOn: dbh.OccurredOn,
		LastUpdate: dbh.LastUpdate,
		UpdatedBy: &model.Recipient{
			ID:               &dbh.UpdatedBy.Id,
			SubjectName:      &dbh.UpdatedBy.SubjectName,
			SubjectThumbnail: &dbh.UpdatedBy.SubjectThumbnail,
			SubjectEmail:     &dbh.UpdatedBy.SubjectThumbnail,
		},
	}, nil
}

// RejectHiringInvitation is the resolver for the rejectHiringInvitation field.
func (r *mutationResolver) RejectHiringInvitation(ctx context.Context, input model.RejectHiringInvitation) (*model.HiringProcess, error) {
	c := commands.NewRejectHiringInvitationCommand(input.UserID, input.HiringProcessID, *input.RejectionReason)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewHiringProcessByIdQuery(input.HiringProcessID)
	dbh, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.HiringProcess{
		ID: dbh.Id,
		Enterprise: &model.Recipient{
			ID:               &dbh.Enterprise.Id,
			SubjectName:      &dbh.Enterprise.SubjectName,
			SubjectThumbnail: &dbh.Enterprise.SubjectThumbnail,
			SubjectEmail:     &dbh.Enterprise.SubjectEmail,
		},
		User: &model.User{
			ID:       dbh.User.Id,
			UserName: dbh.User.Username,
			Person: &model.Person{
				ProfileImg:  dbh.User.Person.ProfileImg,
				Email:       dbh.User.Person.Email,
				FirstName:   dbh.User.Person.FirstName,
				LastName:    dbh.User.Person.LastName,
				Genre:       dbh.User.Person.Genre,
				Pronoun:     dbh.User.Person.Pronoun,
				Age:         dbh.User.Person.Age,
				PhoneNumber: dbh.User.Person.Phone,
				Address: &model.Address{
					Country:      dbh.User.Person.Address.Country,
					CountryState: dbh.User.Person.Address.County,
					City:         dbh.User.Person.Address.City,
				},
			},
			Status: model.UserStatusOffline,
		},
		Role:   dbh.Role,
		Status: (*model.HiringProccessStatus)(&dbh.Status),
		Reason: &dbh.Reason,
		EmitedBy: &model.Recipient{
			ID:               &dbh.EmitedBy.Id,
			SubjectName:      &dbh.EmitedBy.SubjectName,
			SubjectThumbnail: &dbh.EmitedBy.SubjectThumbnail,
			SubjectEmail:     &dbh.EmitedBy.SubjectThumbnail,
		},
		OccurredOn: dbh.OccurredOn,
		LastUpdate: dbh.LastUpdate,
		UpdatedBy: &model.Recipient{
			ID:               &dbh.UpdatedBy.Id,
			SubjectName:      &dbh.UpdatedBy.SubjectName,
			SubjectThumbnail: &dbh.UpdatedBy.SubjectThumbnail,
			SubjectEmail:     &dbh.UpdatedBy.SubjectThumbnail,
		},
	}, nil
}

// HireEmployee is the resolver for the hireEmployee field.
func (r *mutationResolver) HireEmployee(ctx context.Context, input model.HireEmployee) (*model.HiringProcess, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"Enterprise",
		input.EnterpriseID,
		application_services.READ,
		"MANAGER", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	c := commands.NewHireEmployeeCommand(input.HiringProcessID, input.HiredByID)
	err = c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewHiringProcessByIdQuery(input.HiringProcessID)
	dbh, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.HiringProcess{
		ID: dbh.Id,
		Enterprise: &model.Recipient{
			ID:               &dbh.Enterprise.Id,
			SubjectName:      &dbh.Enterprise.SubjectName,
			SubjectThumbnail: &dbh.Enterprise.SubjectThumbnail,
			SubjectEmail:     &dbh.Enterprise.SubjectEmail,
		},
		User: &model.User{
			ID:       dbh.User.Id,
			UserName: dbh.User.Username,
			Person: &model.Person{
				ProfileImg:  dbh.User.Person.ProfileImg,
				Email:       dbh.User.Person.Email,
				FirstName:   dbh.User.Person.FirstName,
				LastName:    dbh.User.Person.LastName,
				Genre:       dbh.User.Person.Genre,
				Pronoun:     dbh.User.Person.Pronoun,
				Age:         dbh.User.Person.Age,
				PhoneNumber: dbh.User.Person.Phone,
				Address: &model.Address{
					Country:      dbh.User.Person.Address.Country,
					CountryState: dbh.User.Person.Address.County,
					City:         dbh.User.Person.Address.City,
				},
			},
			Status: model.UserStatusOffline,
		},
		Role:   dbh.Role,
		Status: (*model.HiringProccessStatus)(&dbh.Status),
		Reason: &dbh.Reason,
		EmitedBy: &model.Recipient{
			ID:               &dbh.EmitedBy.Id,
			SubjectName:      &dbh.EmitedBy.SubjectName,
			SubjectThumbnail: &dbh.EmitedBy.SubjectThumbnail,
			SubjectEmail:     &dbh.EmitedBy.SubjectThumbnail,
		},
		OccurredOn: dbh.OccurredOn,
		LastUpdate: dbh.LastUpdate,
		UpdatedBy: &model.Recipient{
			ID:               &dbh.UpdatedBy.Id,
			SubjectName:      &dbh.UpdatedBy.SubjectName,
			SubjectThumbnail: &dbh.UpdatedBy.SubjectThumbnail,
			SubjectEmail:     &dbh.UpdatedBy.SubjectThumbnail,
		},
	}, nil
}

// PromoteEmployee is the resolver for the promoteEmployee field.
func (r *mutationResolver) PromoteEmployee(ctx context.Context, input model.PromoteEmployee) (*model.Employee, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"Enterprise",
		input.EnterpriseName,
		application_services.READ,
		"MANAGER", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	c := commands.NewPromoteEmployeeCommand(input.EmployeeID, input.PromoteTo, input.PromotedByID)
	err = c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewEmployeeByEmployeeIdQuery(input.EmployeeID)
	employee, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.Employee{
		ID:           employee.ID.String(),
		EnterpriseID: employee.EnterpriseID,
		UserID:       employee.UserID,
		User: &model.User{
			UserName: employee.Email,
			Person: &model.Person{
				ProfileImg:  employee.ProfileIMG,
				Email:       employee.Email,
				FirstName:   employee.FirstName,
				LastName:    employee.LastName,
				Genre:       "",
				Pronoun:     "",
				Age:         employee.Age,
				PhoneNumber: employee.Phone,
				Address:     &model.Address{},
			},
			Status: model.UserStatusOffline,
		},
		HiringDate:         employee.HiringDate,
		ApprovedHiring:     employee.ApprovedHiring,
		ApprovedHiringAt:   employee.ApprovedHiringAt,
		EnterprisePosition: employee.Position,
	}, nil
}

// FireEmployee is the resolver for the fireEmployee field.
func (r *mutationResolver) FireEmployee(ctx context.Context, input model.FireEmployee) (*model.Enterprise, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"Enterprise",
		input.EnterpriseName,
		application_services.READ,
		"MANAGER", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	c := commands.NewFireEmployeeCommand(input.EmployeeID, input.TriggeredBy, input.FireReason)
	err = c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewEnterpriseByNameQuery(input.EnterpriseName)
	enterprise, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	employees := make([]*model.Employee, 0, len(enterprise.Employees))
	for _, v := range enterprise.Employees {
		employees = append(employees, &model.Employee{
			ID:           v.ID.String(),
			EnterpriseID: v.EnterpriseID,
			UserID:       v.UserID,
			User: &model.User{
				ID:       v.UserID,
				UserName: v.Email,
				Person: &model.Person{
					ProfileImg:  v.ProfileIMG,
					Email:       v.Email,
					FirstName:   v.FirstName,
					LastName:    v.LastName,
					Genre:       "",
					Pronoun:     "",
					Age:         v.Age,
					PhoneNumber: v.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         v.HiringDate,
			ApprovedHiring:     v.ApprovedHiring,
			ApprovedHiringAt:   v.ApprovedHiringAt,
			EnterprisePosition: v.Position,
		})
	}
	return &model.Enterprise{
		Name:        enterprise.Name,
		LogoImg:     enterprise.LogoIMG,
		BannerImg:   enterprise.BannerIMG,
		Website:     enterprise.Website,
		Email:       enterprise.Email,
		PhoneNumber: enterprise.Phone,
		Address: &model.Address{
			Country:      enterprise.Address.Country,
			CountryState: enterprise.Address.County,
			City:         enterprise.Address.City,
		},
		Industry: &model.Industry{
			ID:   enterprise.Industry.ID,
			Name: enterprise.Industry.Name,
		},
		FoundationDate: enterprise.FoundationDate,
		OwnerID:        enterprise.OwnerID,
		Employees:      employees,
	}, nil
}

// CancelHiringProcess is the resolver for the cancelHiringProcess field.
func (r *mutationResolver) CancelHiringProcess(ctx context.Context, input model.CancelHiringProcess) (*model.HiringProcess, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"Enterprise",
		input.EnterpriseID,
		application_services.READ,
		"MANAGER", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	c := commands.NewCancelHiringProccessCommand(input.HiringProcessID, input.CanceledBy, input.CancelationReason)
	err = c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewHiringProcessByIdQuery(input.HiringProcessID)
	dbh, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.HiringProcess{
		ID: dbh.Id,
		Enterprise: &model.Recipient{
			ID:               &dbh.Enterprise.Id,
			SubjectName:      &dbh.Enterprise.SubjectName,
			SubjectThumbnail: &dbh.Enterprise.SubjectThumbnail,
			SubjectEmail:     &dbh.Enterprise.SubjectEmail,
		},
		User: &model.User{
			ID:       dbh.User.Id,
			UserName: dbh.User.Username,
			Person: &model.Person{
				ProfileImg:  dbh.User.Person.ProfileImg,
				Email:       dbh.User.Person.Email,
				FirstName:   dbh.User.Person.FirstName,
				LastName:    dbh.User.Person.LastName,
				Genre:       dbh.User.Person.Genre,
				Pronoun:     dbh.User.Person.Pronoun,
				Age:         dbh.User.Person.Age,
				PhoneNumber: dbh.User.Person.Phone,
				Address: &model.Address{
					Country:      dbh.User.Person.Address.Country,
					CountryState: dbh.User.Person.Address.County,
					City:         dbh.User.Person.Address.City,
				},
			},
			Status: model.UserStatusOffline,
		},
		Role:   dbh.Role,
		Status: (*model.HiringProccessStatus)(&dbh.Status),
		Reason: &dbh.Reason,
		EmitedBy: &model.Recipient{
			ID:               &dbh.EmitedBy.Id,
			SubjectName:      &dbh.EmitedBy.SubjectName,
			SubjectThumbnail: &dbh.EmitedBy.SubjectThumbnail,
			SubjectEmail:     &dbh.EmitedBy.SubjectThumbnail,
		},
		OccurredOn: dbh.OccurredOn,
		LastUpdate: dbh.LastUpdate,
		UpdatedBy: &model.Recipient{
			ID:               &dbh.UpdatedBy.Id,
			SubjectName:      &dbh.UpdatedBy.SubjectName,
			SubjectThumbnail: &dbh.UpdatedBy.SubjectThumbnail,
			SubjectEmail:     &dbh.UpdatedBy.SubjectThumbnail,
		},
	}, nil
}

// CreateFeedback is the resolver for the createFeedback field.
func (r *mutationResolver) CreateFeedback(ctx context.Context, input *model.CreateFeedback) (*model.Feedback, error) {
	c := commands.NewCreateFeedbackCommand(input.ComplaintID, input.EnterpriseID)
	err := c.Execute(ctx)
	if err != nil {
		if !errors.Is(err, commands.ErrFeedbackAlreadyExists) {
			return nil, err
		}
	}
	q := queries.NewFeedbackByComplaintIdAndEnterpriseName(input.ComplaintID, input.EnterpriseID)
	dbf, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replyReviews := make([]*model.ReplyReview, 0)
	for _, v := range dbf.ReplyReview {
		replies := make([]*model.ComplaintReply, 0)
		for _, v := range v.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:      &v.Body,
				CreatedAt: &v.CreatedAt,
				Read:      &v.Read,
				ReadAt:    &v.ReadAt,
				UpdatedAt: &v.UpdatedAt,
			})
		}
		replyReviews = append(replyReviews, &model.ReplyReview{
			ID:         v.ID,
			FeedbackID: v.FeedbackID,
			Reviewer: &model.User{
				ID:       v.Reviewer.Id,
				UserName: v.Reviewer.Username,
				Person: &model.Person{
					ProfileImg:  v.Reviewer.Person.ProfileImg,
					Email:       v.Reviewer.Person.Email,
					FirstName:   v.Reviewer.Person.FirstName,
					LastName:    v.Reviewer.Person.LastName,
					Genre:       v.Reviewer.Person.Genre,
					Pronoun:     v.Reviewer.Person.Pronoun,
					Age:         v.Reviewer.Person.Age,
					PhoneNumber: v.Reviewer.Person.Phone,
					Address: &model.Address{
						Country:      v.Reviewer.Person.Address.Country,
						CountryState: v.Reviewer.Person.Address.County,
						City:         v.Reviewer.Person.Address.City,
					},
				},
				Status: model.UserStatusOffline,
			},
			Replies: replies,
			Review: &model.Review{
				ID:      v.Review.ReplyReviewID,
				Comment: &v.Review.Comment,
			},
			Color:     v.Color,
			CreatedAt: v.CreatedAt,
		})
	}
	return &model.Feedback{
		ID:           dbf.Id,
		ComplaintID:  dbf.ComplaintId,
		EnterpriseID: dbf.EnterpriseId,
		ReplyReview:  replyReviews,
		ReviewedAt:   dbf.ReviewedAt,
		UpdatedAt:    dbf.UpdatedAt,
		IsDone:       dbf.IsDone,
	}, nil
}

// CreateNewComplaint is the resolver for the createNewComplaint field.
func (r *mutationResolver) CreateNewComplaint(ctx context.Context, input model.CreateNewComplaint) (*model.Complaint, error) {
	c := commands.NewCreateNewComplaintCommand(input.AuthorID, input.ReceiverID)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewComplaintInWritingStatusQuery(input.AuthorID, input.ReceiverID)
	dbc, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
	for _, v := range dbc.Replies {
		replies = append(replies, &model.ComplaintReply{
			ID:          &v.Id,
			ComplaintID: &v.ComplaintId,
			Sender: &model.Recipient{
				ID:               &v.Sender.Id,
				SubjectName:      &v.Sender.SubjectName,
				SubjectThumbnail: &v.Sender.SubjectThumbnail,
				SubjectEmail:     &v.Sender.SubjectEmail,
				IsEnterprise:     &v.Sender.IsEnterprise,
			},
			Body:      &v.Body,
			CreatedAt: &v.CreatedAt,
			Read:      &v.Read,
			ReadAt:    &v.ReadAt,
			UpdatedAt: &v.UpdatedAt,
		})
	}
	status := model.ComplaintStatus(dbc.Status)
	return &model.Complaint{
		ID: &dbc.Id,
		Author: &model.Recipient{
			ID:               &dbc.Author.Id,
			SubjectName:      &dbc.Author.SubjectName,
			SubjectThumbnail: &dbc.Author.SubjectThumbnail,
			SubjectEmail:     &dbc.Author.SubjectEmail,
			IsEnterprise:     &dbc.Author.IsEnterprise,
		},
		Receiver: &model.Recipient{
			ID:               &dbc.Receiver.Id,
			SubjectName:      &dbc.Receiver.SubjectName,
			SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
			SubjectEmail:     &dbc.Receiver.SubjectEmail,
			IsEnterprise:     &dbc.Receiver.IsEnterprise,
		},
		Status:      &status,
		Title:       &dbc.Title,
		Description: &dbc.Description,
		Rating: &model.Rating{
			ID:      &dbc.Rating.Id,
			Rate:    &dbc.Rating.Rate,
			Comment: &dbc.Rating.Comment,
		},
		CreatedAt: &dbc.CreatedAt,
		UpdatedAt: &dbc.UpdatedAt,
		Replies:   replies,
	}, nil
}

// DescribeComplaint is the resolver for the describeComplaint field.
func (r *mutationResolver) DescribeComplaint(ctx context.Context, input model.DescribeComplaint) (*model.Complaint, error) {
	c := commands.NewDescribeComplaintCommand(input.ComplaintID, input.Description, input.Title)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewComplaintByIdQuery(input.ComplaintID)
	dbc, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
	for _, v := range dbc.Replies {
		replies = append(replies, &model.ComplaintReply{
			ID:          &v.Id,
			ComplaintID: &v.ComplaintId,
			Sender: &model.Recipient{
				ID:               &v.Sender.Id,
				SubjectName:      &v.Sender.SubjectName,
				SubjectThumbnail: &v.Sender.SubjectThumbnail,
				SubjectEmail:     &v.Sender.SubjectEmail,
				IsEnterprise:     &v.Sender.IsEnterprise,
			},
			Body:      &v.Body,
			CreatedAt: &v.CreatedAt,
			Read:      &v.Read,
			ReadAt:    &v.ReadAt,
			UpdatedAt: &v.UpdatedAt,
		})
	}
	status := model.ComplaintStatus(dbc.Status)
	return &model.Complaint{
		ID: &dbc.Id,
		Author: &model.Recipient{
			ID:               &dbc.Author.Id,
			SubjectName:      &dbc.Author.SubjectName,
			SubjectThumbnail: &dbc.Author.SubjectThumbnail,
			SubjectEmail:     &dbc.Author.SubjectEmail,
			IsEnterprise:     &dbc.Author.IsEnterprise,
		},
		Receiver: &model.Recipient{
			ID:               &dbc.Receiver.Id,
			SubjectName:      &dbc.Receiver.SubjectName,
			SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
			SubjectEmail:     &dbc.Receiver.SubjectEmail,
			IsEnterprise:     &dbc.Receiver.IsEnterprise,
		},
		Status:      &status,
		Title:       &dbc.Title,
		Description: &dbc.Description,
		Rating: &model.Rating{
			ID:      &dbc.Rating.Id,
			Rate:    &dbc.Rating.Rate,
			Comment: &dbc.Rating.Comment,
		},
		CreatedAt: &dbc.CreatedAt,
		UpdatedAt: &dbc.UpdatedAt,
		Replies:   replies,
	}, nil
}

// SendComplaint is the resolver for the sendComplaint field.
func (r *mutationResolver) SendComplaint(ctx context.Context, input model.SendComplaint) (*model.Complaint, error) {
	svc := application_services.AuthorizationApplicationServiceInstance()
	currentUser, err := svc.Credentials(ctx)
	if err != nil {
		return nil, err
	}
	c := commands.NewSendComplaintCommand(input.ComplaintID, currentUser.Id, input.Body)
	err = c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewComplaintByIdQuery(input.ComplaintID)
	dbc, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
	for _, v := range dbc.Replies {
		replies = append(replies, &model.ComplaintReply{
			ID:          &v.Id,
			ComplaintID: &v.ComplaintId,
			Sender: &model.Recipient{
				ID:               &v.Sender.Id,
				SubjectName:      &v.Sender.SubjectName,
				SubjectThumbnail: &v.Sender.SubjectThumbnail,
				SubjectEmail:     &v.Sender.SubjectEmail,
				IsEnterprise:     &v.Sender.IsEnterprise,
			},
			Body:      &v.Body,
			CreatedAt: &v.CreatedAt,
			Read:      &v.Read,
			ReadAt:    &v.ReadAt,
			UpdatedAt: &v.UpdatedAt,
		})
	}
	status := model.ComplaintStatus(dbc.Status)
	return &model.Complaint{
		ID: &dbc.Id,
		Author: &model.Recipient{
			ID:               &dbc.Author.Id,
			SubjectName:      &dbc.Author.SubjectName,
			SubjectThumbnail: &dbc.Author.SubjectThumbnail,
			SubjectEmail:     &dbc.Author.SubjectEmail,
			IsEnterprise:     &dbc.Author.IsEnterprise,
		},
		Receiver: &model.Recipient{
			ID:               &dbc.Receiver.Id,
			SubjectName:      &dbc.Receiver.SubjectName,
			SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
			SubjectEmail:     &dbc.Receiver.SubjectEmail,
			IsEnterprise:     &dbc.Receiver.IsEnterprise,
		},
		Status:      &status,
		Title:       &dbc.Title,
		Description: &dbc.Description,
		Rating: &model.Rating{
			ID:      &dbc.Rating.Id,
			Rate:    &dbc.Rating.Rate,
			Comment: &dbc.Rating.Comment,
		},
		CreatedAt: &dbc.CreatedAt,
		UpdatedAt: &dbc.UpdatedAt,
		Replies:   replies,
	}, nil
}

// RateComplaint is the resolver for the rateComplaint field.
func (r *mutationResolver) RateComplaint(ctx context.Context, input model.RateComplaint) (*model.Rating, error) {
	c := commands.NewRateComplaintCommand(input.UserID, input.ComplaintID, input.Comment, input.Rate)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewComplaintByIdQuery(input.ComplaintID)
	dbC, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.Rating{
		ID:      &dbC.Rating.Id,
		Rate:    &dbC.Rating.Rate,
		Comment: &dbC.Rating.Comment,
		SentToReviewBy: &model.Recipient{
			ID:               &dbC.Rating.SentToReviewBy.Id,
			SubjectName:      &dbC.Rating.SentToReviewBy.SubjectName,
			SubjectThumbnail: &dbC.Rating.SentToReviewBy.SubjectThumbnail,
			SubjectEmail:     &dbC.Rating.SentToReviewBy.SubjectEmail,
			IsEnterprise:     &dbC.Rating.SentToReviewBy.IsEnterprise,
		},
		RatedBy: &model.Recipient{
			ID:               &dbC.Rating.RatedBy.Id,
			SubjectName:      &dbC.Rating.RatedBy.SubjectName,
			SubjectThumbnail: &dbC.Rating.RatedBy.SubjectThumbnail,
			SubjectEmail:     &dbC.Rating.RatedBy.SubjectEmail,
			IsEnterprise:     &dbC.Rating.RatedBy.IsEnterprise,
		},
		CreatedAt:  &dbC.Rating.CreatedAt,
		LastUpdate: &dbC.Rating.LastUpdate,
	}, nil
}

// AddFeedbackComment is the resolver for the addFeedbackComment field.
func (r *mutationResolver) AddFeedbackComment(ctx context.Context, input model.AddFeedbackComment) (*model.Feedback, error) {
	c := commands.NewAddFeedbackCommentCommand(input.FeedbackID, input.Color, input.Comment)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewFeedbackByIdQuery(input.FeedbackID)
	dbf, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replyReviews := make([]*model.ReplyReview, 0)
	for _, v := range dbf.ReplyReview {
		replies := make([]*model.ComplaintReply, 0)
		for _, v := range v.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:      &v.Body,
				CreatedAt: &v.CreatedAt,
				Read:      &v.Read,
				ReadAt:    &v.ReadAt,
				UpdatedAt: &v.UpdatedAt,
			})
		}
		replyReviews = append(replyReviews, &model.ReplyReview{
			ID:         v.ID,
			FeedbackID: v.FeedbackID,
			Reviewer: &model.User{
				ID:       v.Reviewer.Id,
				UserName: v.Reviewer.Username,
				Person: &model.Person{
					ProfileImg:  v.Reviewer.Person.ProfileImg,
					Email:       v.Reviewer.Person.Email,
					FirstName:   v.Reviewer.Person.FirstName,
					LastName:    v.Reviewer.Person.LastName,
					Genre:       v.Reviewer.Person.Genre,
					Pronoun:     v.Reviewer.Person.Pronoun,
					Age:         v.Reviewer.Person.Age,
					PhoneNumber: v.Reviewer.Person.Phone,
					Address: &model.Address{
						Country:      v.Reviewer.Person.Address.Country,
						CountryState: v.Reviewer.Person.Address.County,
						City:         v.Reviewer.Person.Address.City,
					},
				},
				Status: model.UserStatusOffline,
			},
			Replies: replies,
			Review: &model.Review{
				ID:      v.Review.ReplyReviewID,
				Comment: &v.Review.Comment,
			},
			Color:     v.Color,
			CreatedAt: v.CreatedAt,
		})
	}
	return &model.Feedback{
		ID:           dbf.Id,
		ComplaintID:  dbf.ComplaintId,
		EnterpriseID: dbf.EnterpriseId,
		ReplyReview:  replyReviews,
		ReviewedAt:   dbf.ReviewedAt,
		UpdatedAt:    dbf.UpdatedAt,
		IsDone:       dbf.IsDone,
	}, nil
}

// AddFeedbackReply is the resolver for the addFeedbackReply field.
func (r *mutationResolver) AddFeedbackReply(ctx context.Context, input model.AddFeedbackReply) (*model.Feedback, error) {
	c := commands.NewAddFeedbackReplyCommand(input.FeedbackID, input.ReviewerID, input.Color, input.RepliesIds)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewFeedbackByIdQuery(input.FeedbackID)
	dbf, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replyReviews := make([]*model.ReplyReview, 0)
	for _, v := range dbf.ReplyReview {
		replies := make([]*model.ComplaintReply, 0)
		for _, v := range v.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:      &v.Body,
				CreatedAt: &v.CreatedAt,
				Read:      &v.Read,
				ReadAt:    &v.ReadAt,
				UpdatedAt: &v.UpdatedAt,
			})
		}
		replyReviews = append(replyReviews, &model.ReplyReview{
			ID:         v.ID,
			FeedbackID: v.FeedbackID,
			Reviewer: &model.User{
				ID:       v.Reviewer.Id,
				UserName: v.Reviewer.Username,
				Person: &model.Person{
					ProfileImg:  v.Reviewer.Person.ProfileImg,
					Email:       v.Reviewer.Person.Email,
					FirstName:   v.Reviewer.Person.FirstName,
					LastName:    v.Reviewer.Person.LastName,
					Genre:       v.Reviewer.Person.Genre,
					Pronoun:     v.Reviewer.Person.Pronoun,
					Age:         v.Reviewer.Person.Age,
					PhoneNumber: v.Reviewer.Person.Phone,
					Address: &model.Address{
						Country:      v.Reviewer.Person.Address.Country,
						CountryState: v.Reviewer.Person.Address.County,
						City:         v.Reviewer.Person.Address.City,
					},
				},
				Status: model.UserStatusOffline,
			},
			Replies: replies,
			Review: &model.Review{
				ID:      v.Review.ReplyReviewID,
				Comment: &v.Review.Comment,
			},
			Color:     v.Color,
			CreatedAt: v.CreatedAt,
		})
	}
	return &model.Feedback{
		ID:           dbf.Id,
		ComplaintID:  dbf.ComplaintId,
		EnterpriseID: dbf.EnterpriseId,
		ReplyReview:  replyReviews,
		ReviewedAt:   dbf.ReviewedAt,
		UpdatedAt:    dbf.UpdatedAt,
		IsDone:       dbf.IsDone,
	}, nil
}

// RemoveFeedbackReply is the resolver for the removeFeedbackReply field.
func (r *mutationResolver) RemoveFeedbackReply(ctx context.Context, input model.RemoveFeedbackReply) (*model.Feedback, error) {
	c := commands.NewRemoveFeedbackReplyCommand(input.FeedbackID, input.Color, input.RepliesIds)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewFeedbackByIdQuery(input.FeedbackID)
	dbf, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replyReviews := make([]*model.ReplyReview, 0)
	for _, v := range dbf.ReplyReview {
		replies := make([]*model.ComplaintReply, 0)
		for _, v := range v.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:      &v.Body,
				CreatedAt: &v.CreatedAt,
				Read:      &v.Read,
				ReadAt:    &v.ReadAt,
				UpdatedAt: &v.UpdatedAt,
			})
		}
		replyReviews = append(replyReviews, &model.ReplyReview{
			ID:         v.ID,
			FeedbackID: v.FeedbackID,
			Reviewer: &model.User{
				ID:       v.Reviewer.Id,
				UserName: v.Reviewer.Username,
				Person: &model.Person{
					ProfileImg:  v.Reviewer.Person.ProfileImg,
					Email:       v.Reviewer.Person.Email,
					FirstName:   v.Reviewer.Person.FirstName,
					LastName:    v.Reviewer.Person.LastName,
					Genre:       v.Reviewer.Person.Genre,
					Pronoun:     v.Reviewer.Person.Pronoun,
					Age:         v.Reviewer.Person.Age,
					PhoneNumber: v.Reviewer.Person.Phone,
					Address: &model.Address{
						Country:      v.Reviewer.Person.Address.Country,
						CountryState: v.Reviewer.Person.Address.County,
						City:         v.Reviewer.Person.Address.City,
					},
				},
				Status: model.UserStatusOffline,
			},
			Replies: replies,
			Review: &model.Review{
				ID:      v.Review.ReplyReviewID,
				Comment: &v.Review.Comment,
			},
			Color:     v.Color,
			CreatedAt: v.CreatedAt,
		})
	}
	return &model.Feedback{
		ID:           dbf.Id,
		ComplaintID:  dbf.ComplaintId,
		EnterpriseID: dbf.EnterpriseId,
		ReplyReview:  replyReviews,
		ReviewedAt:   dbf.ReviewedAt,
		UpdatedAt:    dbf.UpdatedAt,
		IsDone:       dbf.IsDone,
	}, nil
}

// RemoveFeedbackCommand is the resolver for the removeFeedbackCommand field.
func (r *mutationResolver) RemoveFeedbackCommand(ctx context.Context, input model.RemoveFeedbackComment) (*model.Feedback, error) {
	c := commands.NewRemoveFeedbackCommentCommand(input.Color, input.FeedbackID)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewFeedbackByIdQuery(input.FeedbackID)
	dbf, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replyReviews := make([]*model.ReplyReview, 0)
	for _, v := range dbf.ReplyReview {
		replies := make([]*model.ComplaintReply, 0)
		for _, v := range v.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:      &v.Body,
				CreatedAt: &v.CreatedAt,
				Read:      &v.Read,
				ReadAt:    &v.ReadAt,
				UpdatedAt: &v.UpdatedAt,
			})
		}
		replyReviews = append(replyReviews, &model.ReplyReview{
			ID:         v.ID,
			FeedbackID: v.FeedbackID,
			Reviewer: &model.User{
				ID:       v.Reviewer.Id,
				UserName: v.Reviewer.Username,
				Person: &model.Person{
					ProfileImg:  v.Reviewer.Person.ProfileImg,
					Email:       v.Reviewer.Person.Email,
					FirstName:   v.Reviewer.Person.FirstName,
					LastName:    v.Reviewer.Person.LastName,
					Genre:       v.Reviewer.Person.Genre,
					Pronoun:     v.Reviewer.Person.Pronoun,
					Age:         v.Reviewer.Person.Age,
					PhoneNumber: v.Reviewer.Person.Phone,
					Address: &model.Address{
						Country:      v.Reviewer.Person.Address.Country,
						CountryState: v.Reviewer.Person.Address.County,
						City:         v.Reviewer.Person.Address.City,
					},
				},
				Status: model.UserStatusOffline,
			},
			Replies: replies,
			Review: &model.Review{
				ID:      v.Review.ReplyReviewID,
				Comment: &v.Review.Comment,
			},
			Color:     v.Color,
			CreatedAt: v.CreatedAt,
		})
	}
	return &model.Feedback{
		ID:           dbf.Id,
		ComplaintID:  dbf.ComplaintId,
		EnterpriseID: dbf.EnterpriseId,
		ReplyReview:  replyReviews,
		ReviewedAt:   dbf.ReviewedAt,
		UpdatedAt:    dbf.UpdatedAt,
		IsDone:       dbf.IsDone,
	}, nil
}

// EndFeedback is the resolver for the endFeedback field.
func (r *mutationResolver) EndFeedback(ctx context.Context, input model.EndFeedback) (*model.Feedback, error) {
	c := commands.NewEndFeedbackCommand(input.FeedbackID, input.ReviewerID)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewFeedbackByIdQuery(input.FeedbackID)
	dbf, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replyReviews := make([]*model.ReplyReview, 0)
	for _, v := range dbf.ReplyReview {
		replies := make([]*model.ComplaintReply, 0)
		for _, v := range v.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:      &v.Body,
				CreatedAt: &v.CreatedAt,
				Read:      &v.Read,
				ReadAt:    &v.ReadAt,
				UpdatedAt: &v.UpdatedAt,
			})
		}
		replyReviews = append(replyReviews, &model.ReplyReview{
			ID:         v.ID,
			FeedbackID: v.FeedbackID,
			Reviewer: &model.User{
				ID:       v.Reviewer.Id,
				UserName: v.Reviewer.Username,
				Person: &model.Person{
					ProfileImg:  v.Reviewer.Person.ProfileImg,
					Email:       v.Reviewer.Person.Email,
					FirstName:   v.Reviewer.Person.FirstName,
					LastName:    v.Reviewer.Person.LastName,
					Genre:       v.Reviewer.Person.Genre,
					Pronoun:     v.Reviewer.Person.Pronoun,
					Age:         v.Reviewer.Person.Age,
					PhoneNumber: v.Reviewer.Person.Phone,
					Address: &model.Address{
						Country:      v.Reviewer.Person.Address.Country,
						CountryState: v.Reviewer.Person.Address.County,
						City:         v.Reviewer.Person.Address.City,
					},
				},
				Status: model.UserStatusOffline,
			},
			Replies: replies,
			Review: &model.Review{
				ID:      v.Review.ReplyReviewID,
				Comment: &v.Review.Comment,
			},
			Color:     v.Color,
			CreatedAt: v.CreatedAt,
		})
	}
	return &model.Feedback{
		ID:           dbf.Id,
		ComplaintID:  dbf.ComplaintId,
		EnterpriseID: dbf.EnterpriseId,
		ReplyReview:  replyReviews,
		ReviewedAt:   dbf.ReviewedAt,
		UpdatedAt:    dbf.UpdatedAt,
		IsDone:       dbf.IsDone,
	}, nil
}

// CreateEnterpriseChat is the resolver for the createEnterpriseChat field.
func (r *mutationResolver) CreateEnterpriseChat(ctx context.Context, input *model.CreateEnterpriseChat) (*model.Chat, error) {
	c := commands.NewCreateEnterpriseChatCommand(input.EnterpriseID, input.SenderID, input.ReceiverID)
	err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewEnterpriseChatByRecipientsIdAndEnterpriseIdQuery(
		input.EnterpriseID, input.SenderID, input.ReceiverID,
	)
	chat, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replies := make([]*model.ChatReply, 0, len(chat.Replies))
	for _, v := range chat.Replies {
		replies = append(replies, &model.ChatReply{
			ID:     v.Id,
			ChatID: v.ChatId,
			Sender: &model.Recipient{
				ID:               &v.Sender.Id,
				SubjectName:      &v.Sender.SubjectName,
				SubjectThumbnail: &v.Sender.SubjectThumbnail,
				SubjectEmail:     &v.Sender.SubjectEmail,
				IsEnterprise:     &v.Sender.IsEnterprise,
				IsOnline:         &v.Sender.IsOnline,
			},
			Content:   v.Content,
			Seen:      v.Seen,
			CreatedAt: v.CreatedAt,
			UpdatedAt: v.UpdatedAt,
		})
	}
	return &model.Chat{
		ID:           chat.ID,
		EnterpriseID: chat.EnterpriseId,
		RecipientOne: &model.Recipient{
			ID:               &chat.RecipientOne.Id,
			SubjectName:      &chat.RecipientOne.SubjectName,
			SubjectThumbnail: &chat.RecipientOne.SubjectThumbnail,
			SubjectEmail:     &chat.RecipientOne.SubjectEmail,
			IsEnterprise:     &chat.RecipientOne.IsEnterprise,
			IsOnline:         &chat.RecipientOne.IsOnline,
		},
		RecipientTwo: &model.Recipient{
			ID:               &chat.RecipientTwo.Id,
			SubjectName:      &chat.RecipientTwo.SubjectName,
			SubjectThumbnail: &chat.RecipientTwo.SubjectThumbnail,
			SubjectEmail:     &chat.RecipientTwo.SubjectEmail,
			IsEnterprise:     &chat.RecipientTwo.IsEnterprise,
			IsOnline:         &chat.RecipientTwo.IsOnline,
		},
		Replies: replies,
	}, nil
}

// UserDescriptor is the resolver for the userDescriptor field.
func (r *queryResolver) UserDescriptor(ctx context.Context) (*model.UserDescriptor, error) {
	currentUser, err := application_services.AuthorizationApplicationServiceInstance().Credentials(ctx)
	if err != nil {
		return nil, err
	}
	authorities := make([]*model.GrantedAuthority, 0, len(currentUser.GrantedAuthorities))
	for _, v := range currentUser.GrantedAuthorities {
		authorities = append(authorities, &model.GrantedAuthority{
			EnterpriseID: v.EnterpriseID,
			Principal:    v.Principal,
			Authority:    model.Roles(v.Authority),
		})
	}

	return &model.UserDescriptor{
		ID:          currentUser.Id,
		UserName:    currentUser.Email,
		FullName:    currentUser.FullName,
		ProfileImg:  currentUser.ProfileImg,
		Genre:       currentUser.Genre,
		Pronoun:     currentUser.Pronoun,
		Authorities: authorities,
	}, nil
}

// Countries is the resolver for the countries field.
func (r *queryResolver) Countries(ctx context.Context) ([]*model.Country, error) {
	q := queries.NewAllCountriesQuery()
	countries, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Country, 0, len(countries))
	for _, v := range countries {
		result = append(result, &model.Country{
			ID:        v.Id,
			Name:      v.Name,
			PhoneCode: v.PhoneCode,
		})
	}
	return result, nil
}

// CountryStates is the resolver for the countryStates field.
func (r *queryResolver) CountryStates(ctx context.Context, id int) ([]*model.CountryState, error) {
	q := queries.NewCountryStatesByCountryIdQuery(id)
	countryStates, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	result := make([]*model.CountryState, 0, len(countryStates))
	for _, v := range countryStates {
		result = append(result, &model.CountryState{
			ID:   v.Id,
			Name: v.Name,
		})
	}
	return result, nil
}

// Cities is the resolver for the cities field.
func (r *queryResolver) Cities(ctx context.Context, id int) ([]*model.City, error) {
	q := queries.NewCitiesByCountryStateIdQuery(id)
	cities, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	result := make([]*model.City, 0, len(cities))
	for _, v := range cities {
		result = append(result, &model.City{
			ID:          v.Id,
			Name:        v.Name,
			CountryCode: v.CountryCode,
			Latitude:    v.Latitude,
			Longitude:   v.Longitude,
		})
	}
	return result, nil
}

// Industries is the resolver for the industries field.
func (r *queryResolver) Industries(ctx context.Context) ([]*model.Industry, error) {
	q := queries.IndustryQuery{}
	industries, err := q.AllIndustries(ctx)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Industry, 0, len(industries))
	for _, v := range industries {
		result = append(result, &model.Industry{
			ID:   v.ID,
			Name: v.Name,
		})
	}
	return result, nil
}

// RecipientsByNameLike is the resolver for the recipientsByNameLike field.
func (r *queryResolver) RecipientsByNameLike(ctx context.Context, term string) ([]*model.Recipient, error) {
	svc := application_services.AuthorizationApplicationServiceInstance()
	currentUser, err := svc.Credentials(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewFindRecipientsByNameLikeQuery(currentUser.Id, term)
	recipients, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Recipient, 0, len(recipients))
	for _, v := range recipients {
		result = append(result, &model.Recipient{
			ID:               &v.Id,
			SubjectName:      &v.SubjectName,
			SubjectThumbnail: &v.SubjectThumbnail,
			SubjectEmail:     &v.SubjectEmail,
			IsEnterprise:     &v.IsEnterprise,
		})
	}
	return result, nil
}

// ComplaintByID is the resolver for the complaintById field.
func (r *queryResolver) ComplaintByID(ctx context.Context, id string) (*model.Complaint, error) {
	c := queries.NewComplaintByIdQuery(id)
	dbc, err := c.Execute(ctx)
	if err != nil {
		return nil, err
	}
	r.mu.Lock()
	online := chat.ChatServiceInstance().GetChatOnlineClientsIds(dbc.Id)
	r.mu.Unlock()
	log.Print("online", online)
	dbc.Author.IsOnline = slices.Contains(online, dbc.Author.Id)
	dbc.Receiver.IsOnline = slices.Contains(online, dbc.Receiver.Id)
	replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
	repliesSlice := slices.Clone(dbc.Replies)
	for _, v := range repliesSlice {
		reply := &model.ComplaintReply{
			ID:          &v.Id,
			ComplaintID: &v.ComplaintId,
			Sender: &model.Recipient{
				ID:               &v.Sender.Id,
				SubjectName:      &v.Sender.SubjectName,
				SubjectThumbnail: &v.Sender.SubjectThumbnail,
				SubjectEmail:     &v.Sender.SubjectEmail,
				IsEnterprise:     &v.Sender.IsEnterprise,
			},
			Body:         &v.Body,
			CreatedAt:    &v.CreatedAt,
			Read:         &v.Read,
			ReadAt:       &v.ReadAt,
			UpdatedAt:    &v.UpdatedAt,
			IsEnterprise: &v.IsEnterprise,
			EnterpriseID: &v.EnterpriseId,
		}
		isOnline := slices.Contains(online, *reply.Sender.ID)
		reply.Sender.IsOnline = &isOnline
		if &dbc.Author.Id == reply.EnterpriseID && isOnline {
			dbc.Author.IsOnline = isOnline
		}
		if &dbc.Receiver.Id == reply.EnterpriseID && isOnline {
			dbc.Receiver.IsOnline = isOnline
		}

		replies = append(replies, reply)
	}

	status := model.ComplaintStatus(dbc.Status)
	return &model.Complaint{
		ID: &dbc.Id,
		Author: &model.Recipient{
			ID:               &dbc.Author.Id,
			SubjectName:      &dbc.Author.SubjectName,
			SubjectThumbnail: &dbc.Author.SubjectThumbnail,
			SubjectEmail:     &dbc.Author.SubjectEmail,
			IsEnterprise:     &dbc.Author.IsEnterprise,
			IsOnline:         &dbc.Author.IsOnline,
		},
		Receiver: &model.Recipient{
			ID:               &dbc.Receiver.Id,
			SubjectName:      &dbc.Receiver.SubjectName,
			SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
			SubjectEmail:     &dbc.Receiver.SubjectEmail,
			IsEnterprise:     &dbc.Receiver.IsEnterprise,
			IsOnline:         &dbc.Receiver.IsOnline,
		},
		Status:      &status,
		Title:       &dbc.Title,
		Description: &dbc.Description,
		Rating: &model.Rating{
			ID:      &dbc.Rating.Id,
			Rate:    &dbc.Rating.Rate,
			Comment: &dbc.Rating.Comment,
		},
		CreatedAt: &dbc.CreatedAt,
		UpdatedAt: &dbc.UpdatedAt,
		Replies:   replies,
	}, nil
}

// ComplaintWritingByAuthorIDAndReceiverID is the resolver for the complaintWritingByAuthorIdAndReceiverId field.
func (r *queryResolver) ComplaintWritingByAuthorIDAndReceiverID(ctx context.Context, input model.FindComplaintWriting) (*model.Complaint, error) {
	q := queries.NewComplaintInWritingStatusQuery(input.AuthorID, input.ReceiverID)
	dbc, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
	repliesSlice := slices.Clone(dbc.Replies)
	for _, v := range repliesSlice {
		reply := &model.ComplaintReply{
			ID:          &v.Id,
			ComplaintID: &v.ComplaintId,
			Sender: &model.Recipient{
				ID:               &v.Sender.Id,
				SubjectName:      &v.Sender.SubjectName,
				SubjectThumbnail: &v.Sender.SubjectThumbnail,
				SubjectEmail:     &v.Sender.SubjectEmail,
				IsEnterprise:     &v.Sender.IsEnterprise,
			},
			Body:         &v.Body,
			CreatedAt:    &v.CreatedAt,
			Read:         &v.Read,
			ReadAt:       &v.ReadAt,
			UpdatedAt:    &v.UpdatedAt,
			IsEnterprise: &v.IsEnterprise,
			EnterpriseID: &v.EnterpriseId,
		}
		replies = append(replies, reply)
	}
	status := model.ComplaintStatus(dbc.Status)
	return &model.Complaint{
		ID: &dbc.Id,
		Author: &model.Recipient{
			ID:               &dbc.Author.Id,
			SubjectName:      &dbc.Author.SubjectName,
			SubjectThumbnail: &dbc.Author.SubjectThumbnail,
			SubjectEmail:     &dbc.Author.SubjectEmail,
			IsEnterprise:     &dbc.Author.IsEnterprise,
			IsOnline:         &dbc.Author.IsOnline,
		},
		Receiver: &model.Recipient{
			ID:               &dbc.Receiver.Id,
			SubjectName:      &dbc.Receiver.SubjectName,
			SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
			SubjectEmail:     &dbc.Receiver.SubjectEmail,
			IsEnterprise:     &dbc.Receiver.IsEnterprise,
			IsOnline:         &dbc.Receiver.IsOnline,
		},
		Status:      &status,
		Title:       &dbc.Title,
		Description: &dbc.Description,
		Rating: &model.Rating{
			ID:      &dbc.Rating.Id,
			Rate:    &dbc.Rating.Rate,
			Comment: &dbc.Rating.Comment,
		},
		CreatedAt: &dbc.CreatedAt,
		UpdatedAt: &dbc.UpdatedAt,
		Replies:   replies,
	}, nil
}

// ComplaintsByAuthorOrReceiverID is the resolver for the complaintsByAuthorOrReceiverId field.
func (r *queryResolver) ComplaintsByAuthorOrReceiverID(ctx context.Context, id string) ([]*model.Complaint, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"rid",
		id,
		application_services.READ,
		"MANAGER", "ASSISTANT", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	q := queries.NewComplaintsByAuthorOrReceiverIdQuery(id)
	dbcs, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.Complaint, 0, len(dbcs))
	for _, dbc := range dbcs {
		replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
		for _, v := range dbc.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:         &v.Body,
				CreatedAt:    &v.CreatedAt,
				Read:         &v.Read,
				ReadAt:       &v.ReadAt,
				UpdatedAt:    &v.UpdatedAt,
				IsEnterprise: &v.IsEnterprise,
				EnterpriseID: &v.EnterpriseId,
			})
		}
		status := model.ComplaintStatus(dbc.Status)
		results = append(results, &model.Complaint{
			ID: &dbc.Id,
			Author: &model.Recipient{
				ID:               &dbc.Author.Id,
				SubjectName:      &dbc.Author.SubjectName,
				SubjectThumbnail: &dbc.Author.SubjectThumbnail,
				SubjectEmail:     &dbc.Author.SubjectEmail,
				IsEnterprise:     &dbc.Author.IsEnterprise,
			},
			Receiver: &model.Recipient{
				ID:               &dbc.Receiver.Id,
				SubjectName:      &dbc.Receiver.SubjectName,
				SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
				SubjectEmail:     &dbc.Receiver.SubjectEmail,
				IsEnterprise:     &dbc.Receiver.IsEnterprise,
			},
			Status:      &status,
			Title:       &dbc.Title,
			Description: &dbc.Description,
			Rating: &model.Rating{
				ID:      &dbc.Rating.Id,
				Rate:    &dbc.Rating.Rate,
				Comment: &dbc.Rating.Comment,
			},
			CreatedAt: &dbc.CreatedAt,
			UpdatedAt: &dbc.UpdatedAt,
			Replies:   replies,
		})
	}
	return results, nil
}

// PendingReviewsByAuthorID is the resolver for the pendingReviewsByAuthorId field.
func (r *queryResolver) PendingReviewsByAuthorID(ctx context.Context, id string, term *string) ([]*model.Complaint, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"rid",
		id,
		application_services.READ,
		"MANAGER", "ASSISTANT", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	q := queries.NewPendingReviewsByAuthorIdQuery(id, *term)
	dbcs, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.Complaint, 0, len(dbcs))
	for _, dbc := range dbcs {
		replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
		for _, v := range dbc.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:         &v.Body,
				CreatedAt:    &v.CreatedAt,
				Read:         &v.Read,
				ReadAt:       &v.ReadAt,
				UpdatedAt:    &v.UpdatedAt,
				IsEnterprise: &v.IsEnterprise,
				EnterpriseID: &v.EnterpriseId,
			})
		}
		status := model.ComplaintStatus(dbc.Status)
		results = append(results, &model.Complaint{
			ID: &dbc.Id,
			Author: &model.Recipient{
				ID:               &dbc.Author.Id,
				SubjectName:      &dbc.Author.SubjectName,
				SubjectThumbnail: &dbc.Author.SubjectThumbnail,
				SubjectEmail:     &dbc.Author.SubjectEmail,
				IsEnterprise:     &dbc.Author.IsEnterprise,
			},
			Receiver: &model.Recipient{
				ID:               &dbc.Receiver.Id,
				SubjectName:      &dbc.Receiver.SubjectName,
				SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
				SubjectEmail:     &dbc.Receiver.SubjectEmail,
				IsEnterprise:     &dbc.Receiver.IsEnterprise,
			},
			Status:      &status,
			Title:       &dbc.Title,
			Description: &dbc.Description,
			Rating: &model.Rating{
				ID:      &dbc.Rating.Id,
				Rate:    &dbc.Rating.Rate,
				Comment: &dbc.Rating.Comment,
				SentToReviewBy: &model.Recipient{
					ID:               &dbc.Rating.SentToReviewBy.Id,
					SubjectName:      &dbc.Rating.SentToReviewBy.SubjectName,
					SubjectThumbnail: &dbc.Rating.SentToReviewBy.SubjectThumbnail,
					SubjectEmail:     &dbc.Rating.SentToReviewBy.SubjectEmail,
					IsEnterprise:     &dbc.Rating.SentToReviewBy.IsEnterprise,
				},
				RatedBy: &model.Recipient{
					ID:               &dbc.Rating.RatedBy.Id,
					SubjectName:      &dbc.Rating.RatedBy.SubjectName,
					SubjectThumbnail: &dbc.Rating.RatedBy.SubjectThumbnail,
					SubjectEmail:     &dbc.Rating.RatedBy.SubjectEmail,
					IsEnterprise:     &dbc.Rating.RatedBy.IsEnterprise,
				},
				CreatedAt:  &dbc.Rating.CreatedAt,
				LastUpdate: &dbc.Rating.LastUpdate,
			},
			CreatedAt: &dbc.CreatedAt,
			UpdatedAt: &dbc.UpdatedAt,
			Replies:   replies,
		})
	}
	return results, nil
}

// ComplaintsSentForReviewByReceiverID is the resolver for the complaintsSentForReviewByReceiverId field.
func (r *queryResolver) ComplaintsSentForReviewByReceiverID(ctx context.Context, id string, term *string) ([]*model.Complaint, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"rid",
		id,
		application_services.READ,
		"MANAGER", "ASSISTANT", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	q := queries.NewComplaintsSentForReviewByReceiverIdQuery(id, *term)
	dbcs, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.Complaint, 0, len(dbcs))
	for _, dbc := range dbcs {
		replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
		for _, v := range dbc.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:         &v.Body,
				CreatedAt:    &v.CreatedAt,
				Read:         &v.Read,
				ReadAt:       &v.ReadAt,
				UpdatedAt:    &v.UpdatedAt,
				IsEnterprise: &v.IsEnterprise,
				EnterpriseID: &v.EnterpriseId,
			})
		}
		status := model.ComplaintStatus(dbc.Status)
		results = append(results, &model.Complaint{
			ID: &dbc.Id,
			Author: &model.Recipient{
				ID:               &dbc.Author.Id,
				SubjectName:      &dbc.Author.SubjectName,
				SubjectThumbnail: &dbc.Author.SubjectThumbnail,
				SubjectEmail:     &dbc.Author.SubjectEmail,
				IsEnterprise:     &dbc.Author.IsEnterprise,
			},
			Receiver: &model.Recipient{
				ID:               &dbc.Receiver.Id,
				SubjectName:      &dbc.Receiver.SubjectName,
				SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
				SubjectEmail:     &dbc.Receiver.SubjectEmail,
				IsEnterprise:     &dbc.Receiver.IsEnterprise,
			},
			Status:      &status,
			Title:       &dbc.Title,
			Description: &dbc.Description,
			Rating: &model.Rating{
				ID:      &dbc.Rating.Id,
				Rate:    &dbc.Rating.Rate,
				Comment: &dbc.Rating.Comment,
				SentToReviewBy: &model.Recipient{
					ID:               &dbc.Rating.SentToReviewBy.Id,
					SubjectName:      &dbc.Rating.SentToReviewBy.SubjectName,
					SubjectThumbnail: &dbc.Rating.SentToReviewBy.SubjectThumbnail,
					SubjectEmail:     &dbc.Rating.SentToReviewBy.SubjectEmail,
					IsEnterprise:     &dbc.Rating.SentToReviewBy.IsEnterprise,
				},
				RatedBy: &model.Recipient{
					ID:               &dbc.Rating.RatedBy.Id,
					SubjectName:      &dbc.Rating.RatedBy.SubjectName,
					SubjectThumbnail: &dbc.Rating.RatedBy.SubjectThumbnail,
					SubjectEmail:     &dbc.Rating.RatedBy.SubjectEmail,
					IsEnterprise:     &dbc.Rating.RatedBy.IsEnterprise,
				},
				CreatedAt:  &dbc.Rating.CreatedAt,
				LastUpdate: &dbc.Rating.LastUpdate,
			},
			CreatedAt: &dbc.CreatedAt,
			UpdatedAt: &dbc.UpdatedAt,
			Replies:   replies,
		})
	}
	return results, nil
}

// ComplaintsRatedByAuthorID is the resolver for the complaintsRatedByAuthorId field.
func (r *queryResolver) ComplaintsRatedByAuthorID(ctx context.Context, id string, term *string) ([]*model.Complaint, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"rid",
		id,
		application_services.READ,
		"MANAGER", "ASSISTANT", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	q := queries.NewComplaintsRatedByAuthorIdQuery(id, *term)
	dbcs, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.Complaint, 0, len(dbcs))
	for _, dbc := range dbcs {
		replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
		for _, v := range dbc.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:         &v.Body,
				CreatedAt:    &v.CreatedAt,
				Read:         &v.Read,
				ReadAt:       &v.ReadAt,
				UpdatedAt:    &v.UpdatedAt,
				IsEnterprise: &v.IsEnterprise,
				EnterpriseID: &v.EnterpriseId,
			})
		}
		status := model.ComplaintStatus(dbc.Status)
		results = append(results, &model.Complaint{
			ID: &dbc.Id,
			Author: &model.Recipient{
				ID:               &dbc.Author.Id,
				SubjectName:      &dbc.Author.SubjectName,
				SubjectThumbnail: &dbc.Author.SubjectThumbnail,
				SubjectEmail:     &dbc.Author.SubjectEmail,
				IsEnterprise:     &dbc.Author.IsEnterprise,
			},
			Receiver: &model.Recipient{
				ID:               &dbc.Receiver.Id,
				SubjectName:      &dbc.Receiver.SubjectName,
				SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
				SubjectEmail:     &dbc.Receiver.SubjectEmail,
				IsEnterprise:     &dbc.Receiver.IsEnterprise,
			},
			Status:      &status,
			Title:       &dbc.Title,
			Description: &dbc.Description,
			Rating: &model.Rating{
				ID:      &dbc.Rating.Id,
				Rate:    &dbc.Rating.Rate,
				Comment: &dbc.Rating.Comment,
				SentToReviewBy: &model.Recipient{
					ID:               &dbc.Rating.SentToReviewBy.Id,
					SubjectName:      &dbc.Rating.SentToReviewBy.SubjectName,
					SubjectThumbnail: &dbc.Rating.SentToReviewBy.SubjectThumbnail,
					SubjectEmail:     &dbc.Rating.SentToReviewBy.SubjectEmail,
					IsEnterprise:     &dbc.Rating.SentToReviewBy.IsEnterprise,
				},
				RatedBy: &model.Recipient{
					ID:               &dbc.Rating.RatedBy.Id,
					SubjectName:      &dbc.Rating.RatedBy.SubjectName,
					SubjectThumbnail: &dbc.Rating.RatedBy.SubjectThumbnail,
					SubjectEmail:     &dbc.Rating.RatedBy.SubjectEmail,
					IsEnterprise:     &dbc.Rating.RatedBy.IsEnterprise,
				},
				CreatedAt:  &dbc.Rating.CreatedAt,
				LastUpdate: &dbc.Rating.LastUpdate,
			},
			CreatedAt: &dbc.CreatedAt,
			UpdatedAt: &dbc.UpdatedAt,
			Replies:   replies,
		})
	}
	return results, nil
}

// ComplaintsRatedByReceiverID is the resolver for the complaintsRatedByReceiverId field.
func (r *queryResolver) ComplaintsRatedByReceiverID(ctx context.Context, id string, term *string) ([]*model.Complaint, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"rid",
		id,
		application_services.READ,
		"MANAGER", "ASSISTANT", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	q := queries.NewComplaintsRatedByReceiverIdQuery(id, *term)
	dbcs, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.Complaint, 0, len(dbcs))
	for _, dbc := range dbcs {
		replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
		for _, v := range dbc.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:         &v.Body,
				CreatedAt:    &v.CreatedAt,
				Read:         &v.Read,
				ReadAt:       &v.ReadAt,
				UpdatedAt:    &v.UpdatedAt,
				IsEnterprise: &v.IsEnterprise,
				EnterpriseID: &v.EnterpriseId,
			})
		}
		status := model.ComplaintStatus(dbc.Status)
		results = append(results, &model.Complaint{
			ID: &dbc.Id,
			Author: &model.Recipient{
				ID:               &dbc.Author.Id,
				SubjectName:      &dbc.Author.SubjectName,
				SubjectThumbnail: &dbc.Author.SubjectThumbnail,
				SubjectEmail:     &dbc.Author.SubjectEmail,
				IsEnterprise:     &dbc.Author.IsEnterprise,
			},
			Receiver: &model.Recipient{
				ID:               &dbc.Receiver.Id,
				SubjectName:      &dbc.Receiver.SubjectName,
				SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
				SubjectEmail:     &dbc.Receiver.SubjectEmail,
				IsEnterprise:     &dbc.Receiver.IsEnterprise,
			},
			Status:      &status,
			Title:       &dbc.Title,
			Description: &dbc.Description,
			Rating: &model.Rating{
				ID:      &dbc.Rating.Id,
				Rate:    &dbc.Rating.Rate,
				Comment: &dbc.Rating.Comment,
				SentToReviewBy: &model.Recipient{
					ID:               &dbc.Rating.SentToReviewBy.Id,
					SubjectName:      &dbc.Rating.SentToReviewBy.SubjectName,
					SubjectThumbnail: &dbc.Rating.SentToReviewBy.SubjectThumbnail,
					SubjectEmail:     &dbc.Rating.SentToReviewBy.SubjectEmail,
					IsEnterprise:     &dbc.Rating.SentToReviewBy.IsEnterprise,
				},
				RatedBy: &model.Recipient{
					ID:               &dbc.Rating.RatedBy.Id,
					SubjectName:      &dbc.Rating.RatedBy.SubjectName,
					SubjectThumbnail: &dbc.Rating.RatedBy.SubjectThumbnail,
					SubjectEmail:     &dbc.Rating.RatedBy.SubjectEmail,
					IsEnterprise:     &dbc.Rating.RatedBy.IsEnterprise,
				},
				CreatedAt:  &dbc.Rating.CreatedAt,
				LastUpdate: &dbc.Rating.LastUpdate,
			},
			CreatedAt: &dbc.CreatedAt,
			UpdatedAt: &dbc.UpdatedAt,
			Replies:   replies,
		})
	}
	return results, nil
}

// EnterpriseByID is the resolver for the enterpriseById field.
func (r *queryResolver) EnterpriseByName(ctx context.Context, name string) (*model.Enterprise, error) {
	q := queries.NewEnterpriseByNameQuery(name)
	enterprise, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	employees := make([]*model.Employee, 0, len(enterprise.Employees))
	for _, v := range enterprise.Employees {
		employees = append(employees, &model.Employee{
			ID:           v.ID.String(),
			EnterpriseID: v.EnterpriseID,
			UserID:       v.UserID,
			User: &model.User{
				ID:       v.UserID,
				UserName: v.Email,
				Person: &model.Person{
					ProfileImg:  v.ProfileIMG,
					Email:       v.Email,
					FirstName:   v.FirstName,
					LastName:    v.LastName,
					Genre:       "",
					Pronoun:     "",
					Age:         v.Age,
					PhoneNumber: v.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         v.HiringDate,
			ApprovedHiring:     v.ApprovedHiring,
			ApprovedHiringAt:   v.ApprovedHiringAt,
			EnterprisePosition: v.Position,
		})
	}
	return &model.Enterprise{
		ID:          enterprise.Id,
		Name:        enterprise.Name,
		LogoImg:     enterprise.LogoIMG,
		BannerImg:   enterprise.BannerIMG,
		Website:     enterprise.Website,
		Email:       enterprise.Email,
		PhoneNumber: enterprise.Phone,
		Address: &model.Address{
			Country:      enterprise.Address.Country,
			CountryState: enterprise.Address.County,
			City:         enterprise.Address.City,
		},
		Industry: &model.Industry{
			ID:   enterprise.Industry.ID,
			Name: enterprise.Industry.Name,
		},
		FoundationDate: enterprise.FoundationDate,
		OwnerID:        enterprise.OwnerID,
		Employees:      employees,
	}, nil
}

// EnterprisesByAuthenticatedUser is the resolver for the enterprisesByAuthenticatedUser field.
func (r *queryResolver) EnterprisesByAuthenticatedUser(ctx context.Context) (*model.EnterprisesByAuthenticatedUserResult, error) {
	currentUser, err := application_services.AuthorizationApplicationServiceInstance().Credentials(ctx)
	if err != nil {
		return nil, err
	}
	owned := make([]*model.EnterpriseByAuthenticatedUser, 0)
	employed := make([]*model.EnterpriseByAuthenticatedUser, 0)
	for _, v := range currentUser.GrantedAuthorities {
		q := queries.NewEnterpriseByIdQuery(v.EnterpriseID)
		enterprise, err := q.Execute(ctx)
		if errors.Is(err, pgx.ErrNoRows) {
			return &model.EnterprisesByAuthenticatedUserResult{
				Enterprises: owned,
				Offices:     employed,
			}, nil
		}
		if err != nil && !errors.Is(err, pgx.ErrNoRows) {
			return nil, err
		}
		employees := make([]*model.Employee, 0, len(enterprise.Employees))
		for _, v := range enterprise.Employees {
			employees = append(employees, &model.Employee{
				ID:           v.ID.String(),
				EnterpriseID: v.EnterpriseID,
				UserID:       v.UserID,
				User: &model.User{
					UserName: v.Email,
					Person: &model.Person{
						ProfileImg:  v.ProfileIMG,
						Email:       v.Email,
						FirstName:   v.FirstName,
						LastName:    v.LastName,
						Genre:       "",
						Pronoun:     "",
						Age:         v.Age,
						PhoneNumber: v.Phone,
						Address:     &model.Address{},
					},
					Status: model.UserStatusOffline,
				},
				HiringDate:         v.HiringDate,
				ApprovedHiring:     v.ApprovedHiring,
				ApprovedHiringAt:   v.ApprovedHiringAt,
				EnterprisePosition: v.Position,
			})
		}
		model := &model.EnterpriseByAuthenticatedUser{
			Authority: &model.GrantedAuthority{
				Authority:    model.Roles(v.Authority),
				EnterpriseID: v.EnterpriseID,
				Principal:    v.Principal,
			},
			Enterprise: &model.Enterprise{
				Name:        enterprise.Name,
				LogoImg:     enterprise.LogoIMG,
				BannerImg:   enterprise.BannerIMG,
				Website:     enterprise.Website,
				Email:       enterprise.Email,
				PhoneNumber: enterprise.Phone,
				Address: &model.Address{
					Country:      enterprise.Address.Country,
					CountryState: enterprise.Address.County,
					City:         enterprise.Address.City,
				},
				Industry: &model.Industry{
					ID:   enterprise.Industry.ID,
					Name: enterprise.Industry.Name,
				},
				FoundationDate: enterprise.FoundationDate,
				OwnerID:        enterprise.OwnerID,
				Employees:      employees,
			},
		}
		if v.Authority == "OWNER" {
			owned = append(owned, model)
		} else {
			employed = append(employed, model)
		}
	}
	return &model.EnterprisesByAuthenticatedUserResult{
		Enterprises: owned,
		Offices:     employed,
	}, nil
}

// UsersForHiring is the resolver for the usersForHiring field.
func (r *queryResolver) UsersForHiring(ctx context.Context, input model.SearchWithPagination) (*model.UsersForHiringResult, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"Enterprise",
		input.ID,
		application_services.READ,
		"MANAGER", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	q := queries.NewUsersForHiringQuery(
		input.ID,
		input.Query,
		input.Limit,
		input.Offset,
	)
	users, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.User, 0, len(users.Users))
	for _, v := range users.Users {
		results = append(results, &model.User{
			ID:       v.Id,
			UserName: v.Username,
			Person: &model.Person{
				ProfileImg:  v.Person.ProfileImg,
				Email:       v.Person.Email,
				FirstName:   v.Person.FirstName,
				LastName:    v.Person.LastName,
				Genre:       v.Person.Genre,
				Pronoun:     v.Person.Pronoun,
				Age:         v.Person.Age,
				PhoneNumber: v.Person.Phone,
				Address: &model.Address{
					Country:      v.Person.Address.Country,
					CountryState: v.Person.Address.County,
					City:         v.Person.Address.City,
				},
			},
			Status: model.UserStatusOffline,
		})
	}
	return &model.UsersForHiringResult{
		Users:      results,
		Count:      users.Count,
		Limit:      users.CurrentLimit,
		Offset:     users.CurrentOffset,
		NextCursor: users.NextCursor,
		PrevCursor: users.NextCursor - 1,
	}, nil
}

// UserByID is the resolver for the userById field.
func (r *queryResolver) UserByID(ctx context.Context, id string) (*model.User, error) {
	q := queries.NewUserByIdQuery(id)
	user, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	return &model.User{
		UserName: user.Username,
		Person: &model.Person{
			ProfileImg:  user.Person.ProfileImg,
			Email:       user.Person.Email,
			FirstName:   user.Person.FirstName,
			LastName:    user.Person.LastName,
			Genre:       user.Person.Genre,
			Pronoun:     user.Person.Pronoun,
			Age:         user.Person.Age,
			PhoneNumber: user.Person.Phone,
			Address: &model.Address{
				Country:      user.Person.Address.Country,
				CountryState: user.Person.Address.County,
				City:         user.Person.Address.City,
			},
		},
		Status: model.UserStatusOffline,
	}, nil
}

// HiringProcessByAuthenticatedUser is the resolver for the hiringProcessByAuthenticatedUser field.
func (r *queryResolver) HiringProcessByAuthenticatedUser(ctx context.Context) ([]*model.HiringProcess, error) {
	svc := application_services.AuthorizationApplicationServiceInstance()
	currentUser, err := svc.Credentials(ctx)
	if err != nil {
		return nil, err
	}
	q := queries.NewHiringProccessByUserIdQuery(currentUser.Id)
	dbHs, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.HiringProcess, 0, len(dbHs))
	for _, dbh := range dbHs {
		results = append(results, &model.HiringProcess{
			ID: dbh.Id,
			Enterprise: &model.Recipient{
				ID:               &dbh.Enterprise.Id,
				SubjectName:      &dbh.Enterprise.SubjectName,
				SubjectThumbnail: &dbh.Enterprise.SubjectThumbnail,
				SubjectEmail:     &dbh.Enterprise.SubjectEmail,
			},
			User: &model.User{
				ID:       dbh.User.Id,
				UserName: dbh.User.Username,
				Person: &model.Person{
					ProfileImg:  dbh.User.Person.ProfileImg,
					Email:       dbh.User.Person.Email,
					FirstName:   dbh.User.Person.FirstName,
					LastName:    dbh.User.Person.LastName,
					Genre:       dbh.User.Person.Genre,
					Pronoun:     dbh.User.Person.Pronoun,
					Age:         dbh.User.Person.Age,
					PhoneNumber: dbh.User.Person.Phone,
					Address: &model.Address{
						Country:      dbh.User.Person.Address.Country,
						CountryState: dbh.User.Person.Address.County,
						City:         dbh.User.Person.Address.City,
					},
				},
				Status: model.UserStatusOffline,
			},
			Role:   dbh.Role,
			Status: (*model.HiringProccessStatus)(&dbh.Status),
			Reason: &dbh.Reason,
			EmitedBy: &model.Recipient{
				ID:               &dbh.EmitedBy.Id,
				SubjectName:      &dbh.EmitedBy.SubjectName,
				SubjectThumbnail: &dbh.EmitedBy.SubjectThumbnail,
				SubjectEmail:     &dbh.EmitedBy.SubjectThumbnail,
			},
			OccurredOn: dbh.OccurredOn,
			LastUpdate: dbh.LastUpdate,
			UpdatedBy: &model.Recipient{
				ID:               &dbh.UpdatedBy.Id,
				SubjectName:      &dbh.UpdatedBy.SubjectName,
				SubjectThumbnail: &dbh.UpdatedBy.SubjectThumbnail,
				SubjectEmail:     &dbh.UpdatedBy.SubjectThumbnail,
			},
			Industry: &model.Industry{
				ID:   dbh.Industry.ID,
				Name: dbh.Industry.Name,
			},
		})
	}
	return results, nil
}

// HiringProcessByEnterpriseName is the resolver for the hiringProcessByEnterpriseName field.
func (r *queryResolver) HiringProcessByEnterpriseName(ctx context.Context, name string) ([]*model.HiringProcess, error) {
	_, err := application_services.AuthorizationApplicationServiceInstance().ResourceAccess(
		ctx,
		"Enterprise",
		name,
		application_services.READ,
		"MANAGER", "OWNER",
	)
	if err != nil {
		return nil, err
	}
	q := queries.NewHiringProccessByEnterpriseNameQuery(name)
	dbHs, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.HiringProcess, 0, len(dbHs))
	for _, dbh := range dbHs {
		results = append(results, &model.HiringProcess{
			ID: dbh.Id,
			Enterprise: &model.Recipient{
				ID:               &dbh.Enterprise.Id,
				SubjectName:      &dbh.Enterprise.SubjectName,
				SubjectThumbnail: &dbh.Enterprise.SubjectThumbnail,
				SubjectEmail:     &dbh.Enterprise.SubjectEmail,
			},
			User: &model.User{
				ID:       dbh.User.Id,
				UserName: dbh.User.Username,
				Person: &model.Person{
					ProfileImg:  dbh.User.Person.ProfileImg,
					Email:       dbh.User.Person.Email,
					FirstName:   dbh.User.Person.FirstName,
					LastName:    dbh.User.Person.LastName,
					Genre:       dbh.User.Person.Genre,
					Pronoun:     dbh.User.Person.Pronoun,
					Age:         dbh.User.Person.Age,
					PhoneNumber: dbh.User.Person.Phone,
					Address: &model.Address{
						Country:      dbh.User.Person.Address.Country,
						CountryState: dbh.User.Person.Address.County,
						City:         dbh.User.Person.Address.City,
					},
				},
				Status: model.UserStatusOffline,
			},
			Role:   dbh.Role,
			Status: (*model.HiringProccessStatus)(&dbh.Status),
			Reason: &dbh.Reason,
			EmitedBy: &model.Recipient{
				ID:               &dbh.EmitedBy.Id,
				SubjectName:      &dbh.EmitedBy.SubjectName,
				SubjectThumbnail: &dbh.EmitedBy.SubjectThumbnail,
				SubjectEmail:     &dbh.EmitedBy.SubjectThumbnail,
			},
			OccurredOn: dbh.OccurredOn,
			LastUpdate: dbh.LastUpdate,
			UpdatedBy: &model.Recipient{
				ID:               &dbh.UpdatedBy.Id,
				SubjectName:      &dbh.UpdatedBy.SubjectName,
				SubjectThumbnail: &dbh.UpdatedBy.SubjectThumbnail,
				SubjectEmail:     &dbh.UpdatedBy.SubjectThumbnail,
			},
			Industry: &model.Industry{
				ID:   dbh.Industry.ID,
				Name: dbh.Industry.Name,
			},
		})
	}
	return results, nil
}

// ComplaintsForFeedbackByEmployeeID is the resolver for the complaintsForFeedbackByEmployeeId field.
func (r *queryResolver) ComplaintsForFeedbackByEmployeeID(ctx context.Context, id string) ([]*model.Complaint, error) {
	q := queries.NewComplaintsForFeedbackByEmployeeIdQuery(id)
	dbcs, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.Complaint, 0, len(dbcs))
	for _, dbc := range dbcs {
		replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
		for _, v := range dbc.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:         &v.Body,
				CreatedAt:    &v.CreatedAt,
				Read:         &v.Read,
				ReadAt:       &v.ReadAt,
				UpdatedAt:    &v.UpdatedAt,
				IsEnterprise: &v.IsEnterprise,
				EnterpriseID: &v.EnterpriseId,
			})
		}
		status := model.ComplaintStatus(dbc.Status)
		results = append(results, &model.Complaint{
			ID: &dbc.Id,
			Author: &model.Recipient{
				ID:               &dbc.Author.Id,
				SubjectName:      &dbc.Author.SubjectName,
				SubjectThumbnail: &dbc.Author.SubjectThumbnail,
				SubjectEmail:     &dbc.Author.SubjectEmail,
				IsEnterprise:     &dbc.Author.IsEnterprise,
			},
			Receiver: &model.Recipient{
				ID:               &dbc.Receiver.Id,
				SubjectName:      &dbc.Receiver.SubjectName,
				SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
				SubjectEmail:     &dbc.Receiver.SubjectEmail,
				IsEnterprise:     &dbc.Receiver.IsEnterprise,
			},
			Status:      &status,
			Title:       &dbc.Title,
			Description: &dbc.Description,
			Rating: &model.Rating{
				ID:      &dbc.Rating.Id,
				Rate:    &dbc.Rating.Rate,
				Comment: &dbc.Rating.Comment,
			},
			CreatedAt: &dbc.CreatedAt,
			UpdatedAt: &dbc.UpdatedAt,
			Replies:   replies,
		})
	}
	return results, nil
}

// ComplaintsOfResolvedFeedbackByEmployeeID is the resolver for the complaintsOfResolvedFeedbackByEmployeeId field.
func (r *queryResolver) ComplaintsOfResolvedFeedbackByEmployeeID(ctx context.Context, id string) ([]*model.Complaint, error) {
	q := queries.NewComplaintsOfResolvedFeedbacksByEmployeeId(id)
	dbcs, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.Complaint, 0, len(dbcs))
	for _, dbc := range dbcs {
		replies := make([]*model.ComplaintReply, 0, len(dbc.Replies))
		for _, v := range dbc.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:         &v.Body,
				CreatedAt:    &v.CreatedAt,
				Read:         &v.Read,
				ReadAt:       &v.ReadAt,
				UpdatedAt:    &v.UpdatedAt,
				IsEnterprise: &v.IsEnterprise,
				EnterpriseID: &v.EnterpriseId,
			})
		}
		status := model.ComplaintStatus(dbc.Status)
		results = append(results, &model.Complaint{
			ID: &dbc.Id,
			Author: &model.Recipient{
				ID:               &dbc.Author.Id,
				SubjectName:      &dbc.Author.SubjectName,
				SubjectThumbnail: &dbc.Author.SubjectThumbnail,
				SubjectEmail:     &dbc.Author.SubjectEmail,
				IsEnterprise:     &dbc.Author.IsEnterprise,
			},
			Receiver: &model.Recipient{
				ID:               &dbc.Receiver.Id,
				SubjectName:      &dbc.Receiver.SubjectName,
				SubjectThumbnail: &dbc.Receiver.SubjectThumbnail,
				SubjectEmail:     &dbc.Receiver.SubjectEmail,
				IsEnterprise:     &dbc.Receiver.IsEnterprise,
			},
			Status:      &status,
			Title:       &dbc.Title,
			Description: &dbc.Description,
			Rating: &model.Rating{
				ID:      &dbc.Rating.Id,
				Rate:    &dbc.Rating.Rate,
				Comment: &dbc.Rating.Comment,
			},
			CreatedAt: &dbc.CreatedAt,
			UpdatedAt: &dbc.UpdatedAt,
			Replies:   replies,
		})
	}
	return results, nil
}

// FindEnterpriseChat is the resolver for the findEnterpriseChat field.
func (r *queryResolver) FindEnterpriseChat(ctx context.Context, input model.FindEnterpriseChat) (*model.Chat, error) {
	q := queries.NewEnterpriseChatByRecipientsIdAndEnterpriseIdQuery(
		input.EnterpriseID, input.RecipientOneID, input.RecipientTwoID,
	)
	chat, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	replies := make([]*model.ChatReply, 0)
	for _, v := range chat.Replies {
		replies = append(replies, &model.ChatReply{
			ID:     v.Id,
			ChatID: v.ChatId,
			Sender: &model.Recipient{
				ID:               &v.Sender.Id,
				SubjectName:      &v.Sender.SubjectName,
				SubjectThumbnail: &v.Sender.SubjectThumbnail,
				SubjectEmail:     &v.Sender.SubjectEmail,
				IsEnterprise:     &v.Sender.IsEnterprise,
				IsOnline:         &v.Sender.IsOnline,
			},
			Content:   v.Content,
			Seen:      v.Seen,
			CreatedAt: v.CreatedAt,
			UpdatedAt: v.UpdatedAt,
		})
	}
	return &model.Chat{
		ID:           chat.ID,
		EnterpriseID: chat.EnterpriseId,
		RecipientOne: &model.Recipient{
			ID:               &chat.RecipientOne.Id,
			SubjectName:      &chat.RecipientOne.SubjectName,
			SubjectThumbnail: &chat.RecipientOne.SubjectThumbnail,
			SubjectEmail:     &chat.RecipientOne.SubjectEmail,
			IsEnterprise:     &chat.RecipientOne.IsEnterprise,
			IsOnline:         &chat.RecipientOne.IsOnline,
		},
		RecipientTwo: &model.Recipient{
			ID:               &chat.RecipientTwo.Id,
			SubjectName:      &chat.RecipientTwo.SubjectName,
			SubjectThumbnail: &chat.RecipientTwo.SubjectThumbnail,
			SubjectEmail:     &chat.RecipientTwo.SubjectEmail,
			IsEnterprise:     &chat.RecipientTwo.IsEnterprise,
			IsOnline:         &chat.RecipientTwo.IsOnline,
		},
		Replies: replies,
	}, nil
}

// Notifications is the resolver for the notifications field.
func (r *subscriptionResolver) Notifications(ctx context.Context, id string) (<-chan *model.NotificationLink, error) {
	q := queries.NewNotificationsByOwnerIdQuery(id)
	stored, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	toModel := make([]*model.NotificationLink, 0, len(stored))
	for _, n := range stored {
		toModel = append(toModel, &model.NotificationLink{
			ID: n.Id,
			Owner: &model.Recipient{
				ID:               &n.Owner.Id,
				SubjectName:      &n.Owner.SubjectName,
				SubjectThumbnail: &n.Owner.SubjectThumbnail,
				IsEnterprise:     &n.Owner.IsEnterprise,
			},
			Sender: &model.Recipient{
				ID:               &n.Sender.Id,
				SubjectName:      &n.Sender.SubjectName,
				SubjectThumbnail: &n.Sender.SubjectThumbnail,
				IsEnterprise:     &n.Sender.IsEnterprise,
			},
			Title:      n.Title,
			Content:    n.Content,
			Link:       n.Link,
			Seen:       n.Seen,
			OccurredOn: n.OccurredOn,
		})
	}
	in := make(chan application.ApplicationMessage)
	sub := &application.Subscriber{
		Id:   id,
		Send: in,
	}
	r.Publisher.Subscribe(sub)
	ch := make(chan *model.NotificationLink)
	go func() {
		defer func() {
			r.Publisher.Unsubscribe(sub)
			close(ch)
		}()
		for i := range toModel {
			ch <- toModel[i]
		}
		for {
			select {
			case <-ctx.Done():
				return
			case m := <-in:
				if m.DataType() == "notification" {
					n, ok := m.Value().(dto.Notification)
					if ok {
						ch <- &model.NotificationLink{
							ID: n.Id,
							Owner: &model.Recipient{
								ID:               &n.Owner.Id,
								SubjectName:      &n.Owner.SubjectName,
								SubjectThumbnail: &n.Owner.SubjectThumbnail,
								IsEnterprise:     &n.Owner.IsEnterprise,
							},
							Sender: &model.Recipient{
								ID:               &n.Sender.Id,
								SubjectName:      &n.Sender.SubjectName,
								SubjectThumbnail: &n.Sender.SubjectThumbnail,
								IsEnterprise:     &n.Sender.IsEnterprise,
							},
							Title:      n.Title,
							Content:    n.Content,
							Link:       n.Link,
							Seen:       n.Seen,
							OccurredOn: n.OccurredOn,
						}
					}
				}
			}
		}
	}()
	return ch, nil
}

// Complaints is the resolver for the complaints field.
func (r *subscriptionResolver) Complaints(ctx context.Context, id string, userID string) (<-chan *model.Complaint, error) {
	q := queries.NewComplaintsByAuthorOrReceiverIdQuery(id)
	stored, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	toModel := make([]*model.Complaint, 0)
	for _, v := range stored {
		replies := make([]*model.ComplaintReply, 0, len(v.Replies))
		for _, r := range v.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &r.Id,
				ComplaintID: &r.ComplaintId,
				Sender: &model.Recipient{
					ID:               &r.Sender.Id,
					SubjectName:      &r.Sender.SubjectName,
					SubjectThumbnail: &r.Sender.SubjectThumbnail,
					IsEnterprise:     &r.Sender.IsEnterprise,
					IsOnline:         &r.Sender.IsOnline,
				},
				Body:      &r.Body,
				CreatedAt: &r.CreatedAt,
				Read:      &r.Read,
				ReadAt:    &r.ReadAt,
				UpdatedAt: &r.UpdatedAt,
			})
		}
		status := model.ComplaintStatus(v.Status)
		toModel = append(toModel, &model.Complaint{
			ID: &v.Id,
			Author: &model.Recipient{
				ID:               &v.Author.Id,
				SubjectName:      &v.Author.SubjectName,
				SubjectThumbnail: &v.Author.SubjectThumbnail,
				IsEnterprise:     &v.Author.IsEnterprise,
				IsOnline:         &v.Author.IsOnline,
			},
			Receiver: &model.Recipient{
				ID:               &v.Receiver.Id,
				SubjectName:      &v.Receiver.SubjectName,
				SubjectThumbnail: &v.Receiver.SubjectThumbnail,
				IsEnterprise:     &v.Receiver.IsEnterprise,
				IsOnline:         &v.Receiver.IsOnline,
			},
			Status:      &status,
			Title:       &v.Title,
			Description: &v.Description,
			Rating: &model.Rating{
				ID:      &v.Rating.Id,
				Rate:    &v.Rating.Rate,
				Comment: &v.Rating.Comment,
			},
			CreatedAt: &v.CreatedAt,
			UpdatedAt: &v.UpdatedAt,
			Replies:   replies,
		})
	}
	in := make(chan application.ApplicationMessage)
	sub := &application.Subscriber{
		Id:     id,
		Send:   in,
		UserId: userID,
	}
	r.Publisher.Subscribe(sub)
	ch := make(chan *model.Complaint)
	go func() {
		defer func() {
			r.Publisher.Unsubscribe(sub)
			close(ch)
		}()
		for _, v := range toModel {
			//log.Printf("stored author %s=%v  \n stored receiver %s=%v \n", v.Author.ID, v.Author.IsOnline, v.Receiver.ID, v.Author.IsOnline)
			ch <- v
		}
		for {
			select {
			case <-ctx.Done():
				return
			case m := <-in:
				if m.DataType() == "subscriber_connected" {
					//log.Printf("sub conn subs: %v", r.Publisher.ApplicationSubscribers())
					isOnline := true
					connSub, ok := m.Value().(*application.Subscriber)
					if ok {
						log.Printf("sub connected %v", connSub)
						for _, v := range toModel {
							switch connSub.Id {
							case *v.Author.ID:
								log.Printf("connected sub.id == author.id")
								r.mu.Lock()
								v.Author.IsOnline = &isOnline
								r.mu.Unlock()
								ch <- v
							case *v.Receiver.ID:
								log.Printf("connected sub.id == receiver.id")
								r.mu.Lock()
								v.Receiver.IsOnline = &isOnline
								r.mu.Unlock()
								ch <- v
							default:
								log.Printf("sub.id does not match any authors %s", sub.Id)
							}
							switch connSub.UserId {
							case *v.Author.ID:
								log.Printf("connected sub.userid == author.id")
								r.mu.Lock()
								v.Author.IsOnline = &isOnline
								r.mu.Unlock()
								ch <- v
							case *v.Receiver.ID:
								log.Printf("connected sub.userid == receiver.id")
								r.mu.Lock()
								v.Receiver.IsOnline = &isOnline
								r.mu.Unlock()
								ch <- v
							default:
								log.Printf("sub.userid does not match any authors %s", sub.Id)
							}
						}
					}
				}
				if m.DataType() == "subscriber_disconnected" {
					isOnline := false
					disConnSub, ok := m.Value().(*application.Subscriber)
					if ok {
						log.Printf("sub disconnected %v", disConnSub)
						for _, v := range toModel {
							switch disConnSub.Id {
							case *v.Author.ID:
								log.Printf("disconnected sub.id == author.id")
								r.mu.Lock()
								v.Author.IsOnline = &isOnline
								r.mu.Unlock()
								ch <- v
							case *v.Receiver.ID:
								log.Printf("disconnected sub.id == receiver.id")
								r.mu.Lock()
								v.Receiver.IsOnline = &isOnline
								r.mu.Unlock()
								ch <- v
							default:
								log.Printf("dissub.id does not match any authors %s", sub.Id)
							}
							switch disConnSub.UserId {
							case *v.Author.ID:
								log.Printf("disconnected sub.userid == author.id")
								r.mu.Lock()
								v.Author.IsOnline = &isOnline
								r.mu.Unlock()
								ch <- v
							case *v.Receiver.ID:
								log.Printf("disconnected sub.userid == receiver.id")
								r.mu.Lock()
								v.Receiver.IsOnline = &isOnline
								r.mu.Unlock()
								ch <- v
							default:
								log.Printf("sub.userid doesnot match any authors %s", sub.Id)
							}
						}
					}
				}
				if m.DataType() == "complaint" {
					v, ok := m.Value().(dto.Complaint)
					if ok {
						replies := make([]*model.ComplaintReply, 0, len(v.Replies))
						status := model.ComplaintStatus(v.Status)
						for _, r := range v.Replies {
							replies = append(replies, &model.ComplaintReply{
								ID:          &r.Id,
								ComplaintID: &r.ComplaintId,
								Sender: &model.Recipient{
									ID:               &r.Sender.Id,
									SubjectName:      &r.Sender.SubjectName,
									SubjectThumbnail: &r.Sender.SubjectThumbnail,
									IsEnterprise:     &r.Sender.IsEnterprise,
									IsOnline:         &r.Sender.IsOnline,
								},
								Body:      &r.Body,
								CreatedAt: &r.CreatedAt,
								Read:      &r.Read,
								ReadAt:    &r.ReadAt,
								UpdatedAt: &r.UpdatedAt,
							})
						}
						casted := &model.Complaint{
							ID: &v.Id,
							Author: &model.Recipient{
								ID:               &v.Author.Id,
								SubjectName:      &v.Author.SubjectName,
								SubjectThumbnail: &v.Author.SubjectThumbnail,
								IsEnterprise:     &v.Author.IsEnterprise,
								IsOnline:         &v.Author.IsOnline,
							},
							Receiver: &model.Recipient{
								ID:               &v.Receiver.Id,
								SubjectName:      &v.Receiver.SubjectName,
								SubjectThumbnail: &v.Receiver.SubjectThumbnail,
								IsEnterprise:     &v.Receiver.IsEnterprise,
								IsOnline:         &v.Receiver.IsOnline,
							},
							Status:      &status,
							Title:       &v.Title,
							Description: &v.Description,
							Rating: &model.Rating{
								ID:      &v.Rating.Id,
								Rate:    &v.Rating.Rate,
								Comment: &v.Rating.Comment,
							},
							CreatedAt: &v.CreatedAt,
							UpdatedAt: &v.UpdatedAt,
							Replies:   replies,
						}
						toModel = append(toModel, casted)
						ch <- casted
					}
				}
			}
		}
	}()
	return ch, nil
}

// EmployeesActivityLog is the resolver for the employeesActivityLog field.
func (r *subscriptionResolver) EmployeesActivityLog(ctx context.Context, id string) (<-chan *model.EnterpriseActivity, error) {
	q := queries.NewEnterpriseActivityByEnterpriseNameQuery(id)
	stored, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	svc := application.ApplicationMessagePublisherInstance()
	in := make(chan application.ApplicationMessage)
	sub := &application.Subscriber{Id: id, Send: in}
	svc.Subscribe(sub)
	ch := make(chan *model.EnterpriseActivity)
	go func() {
		defer func() {
			r.Publisher.Unsubscribe(sub)
			close(ch)
		}()
		for _, v := range stored {
			ch <- &model.EnterpriseActivity{
				ID: v.Id,
				User: &model.Recipient{
					ID:               &v.User.Id,
					SubjectName:      &v.User.SubjectName,
					SubjectEmail:     &v.User.SubjectEmail,
					SubjectThumbnail: &v.User.SubjectThumbnail,
				},
				ActivityID:     v.ActivityId,
				EnterpriseID:   v.EnterpriseId,
				EnterpriseName: v.EnterpriseName,
				OccurredOn:     v.OccurredOn,
				ActivityType:   model.EnterpriseActivityType(v.ActivityType),
			}
		}
		for {
			select {
			case <-ctx.Done():
				return
			case m := <-in:
				if m.DataType() == "enterpriseActivity" {
					v, ok := m.Value().(dto.EnterpriseActivity)
					if ok {
						ch <- &model.EnterpriseActivity{
							ID: v.Id,
							User: &model.Recipient{
								ID:               &v.User.Id,
								SubjectName:      &v.User.SubjectName,
								SubjectEmail:     &v.User.SubjectEmail,
								SubjectThumbnail: &v.User.SubjectThumbnail,
							},
							ActivityID:     v.ActivityId,
							EnterpriseID:   v.EnterpriseId,
							EnterpriseName: v.EnterpriseName,
							OccurredOn:     v.OccurredOn,
							ActivityType:   model.EnterpriseActivityType(v.ActivityType),
						}
					}
				}
			}
		}
	}()
	return ch, nil
}

// EmployeeActivity is the resolver for the employeeActivity field.
func (r *subscriptionResolver) EmployeeActivity(ctx context.Context, id string) (<-chan *model.EnterpriseActivity, error) {
	q := queries.NewEnterpriseActivityByUserIdQuery(id)
	stored, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	svc := application.ApplicationMessagePublisherInstance()
	in := make(chan application.ApplicationMessage)
	sub := &application.Subscriber{Id: id, Send: in}
	svc.Subscribe(sub)
	ch := make(chan *model.EnterpriseActivity)
	go func() {
		defer func() {
			r.Publisher.Unsubscribe(sub)
			close(ch)
		}()
		for _, v := range stored {
			ch <- &model.EnterpriseActivity{
				ID: v.Id,
				User: &model.Recipient{
					ID:               &v.User.Id,
					SubjectName:      &v.User.SubjectName,
					SubjectEmail:     &v.User.SubjectEmail,
					SubjectThumbnail: &v.User.SubjectThumbnail,
				},
				ActivityID:     v.ActivityId,
				EnterpriseID:   v.EnterpriseId,
				EnterpriseName: v.EnterpriseName,
				OccurredOn:     v.OccurredOn,
				ActivityType:   model.EnterpriseActivityType(v.ActivityType),
			}
		}
		for {
			select {
			case <-ctx.Done():
				return
			case m := <-in:
				if m.DataType() == "enterpriseActivity" {
					v, ok := m.Value().(dto.EnterpriseActivity)
					if ok {
						ch <- &model.EnterpriseActivity{
							ID: v.Id,
							User: &model.Recipient{
								ID:               &v.User.Id,
								SubjectName:      &v.User.SubjectName,
								SubjectEmail:     &v.User.SubjectEmail,
								SubjectThumbnail: &v.User.SubjectThumbnail,
							},
							ActivityID:     v.ActivityId,
							EnterpriseID:   v.EnterpriseId,
							EnterpriseName: v.EnterpriseName,
							OccurredOn:     v.OccurredOn,
							ActivityType:   model.EnterpriseActivityType(v.ActivityType),
						}
					}
				}
			}
		}
	}()
	return ch, nil
}

// EmployeeComplaintData is the resolver for the employeeComplaintData field.
func (r *subscriptionResolver) EmployeeComplaintData(ctx context.Context, id string) (<-chan *model.ComplaintData, error) {
	q := queries.NewComplaintDataByEmployeeUserIdQuery(id)
	stored, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	svc := application.ApplicationMessagePublisherInstance()
	in := make(chan application.ApplicationMessage)
	sub := &application.Subscriber{Id: id, Send: in}
	svc.Subscribe(sub)
	ch := make(chan *model.ComplaintData)
	go func() {
		defer func() {
			r.Publisher.Unsubscribe(sub)
			close(ch)
		}()
		for _, v := range stored {
			ch <- &model.ComplaintData{
				ID:          v.Id,
				OwnerID:     v.OwnerId,
				ComplaintID: v.ComplaintId,
				OccurredOn:  v.OccurredOn,
				DataType:    model.ComplaintDataType(v.DataType),
			}
		}
		for {
			select {
			case <-ctx.Done():
				return
			case m := <-in:
				if m.DataType() == "complaintData" {
					v, ok := m.Value().(dto.ComplaintData)
					if ok {
						ch <- &model.ComplaintData{
							ID:          v.Id,
							OwnerID:     v.OwnerId,
							ComplaintID: v.ComplaintId,
							OccurredOn:  v.OccurredOn,
							DataType:    model.ComplaintDataType(v.DataType),
						}
					}
				}
			}
		}
	}()
	return ch, nil
}

// ComplaintDataByOwnership is the resolver for the complaintDataByOwnership field.
func (r *subscriptionResolver) ComplaintDataByOwnership(ctx context.Context, id string) (<-chan *model.ComplaintData, error) {
	q := queries.NewComplaintDataByOwnerIdQuery(id)
	stored, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	svc := application.ApplicationMessagePublisherInstance()
	in := make(chan application.ApplicationMessage)
	sub := &application.Subscriber{Id: id, Send: in}
	svc.Subscribe(sub)
	ch := make(chan *model.ComplaintData)
	go func() {
		defer func() {
			r.Publisher.Unsubscribe(sub)
			close(ch)
		}()
		for _, v := range stored {
			ch <- &model.ComplaintData{
				ID:          v.Id,
				OwnerID:     v.OwnerId,
				ComplaintID: v.ComplaintId,
				OccurredOn:  v.OccurredOn,
				DataType:    model.ComplaintDataType(v.DataType),
			}
		}
		for {
			select {
			case <-ctx.Done():
				return
			case m := <-in:
				if m.DataType() == "complaintData" {
					v, ok := m.Value().(dto.ComplaintData)
					if ok {
						ch <- &model.ComplaintData{
							ID:          v.Id,
							OwnerID:     v.OwnerId,
							ComplaintID: v.ComplaintId,
							OccurredOn:  v.OccurredOn,
							DataType:    model.ComplaintDataType(v.DataType),
						}
					}
				}
			}
		}
	}()
	return ch, nil
}

// Feedback is the resolver for the feedback field.
func (r *subscriptionResolver) Feedback(ctx context.Context, feedbackID string) (<-chan *model.Feedback, error) {
	q := queries.NewFeedbackByIdQuery(feedbackID)
	dbf, err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	svc := application.ApplicationMessagePublisherInstance()
	in := make(chan application.ApplicationMessage)
	sub := &application.Subscriber{Id: feedbackID, Send: in}
	svc.Subscribe(sub)
	ch := make(chan *model.Feedback)
	replyReviews := make([]*model.ReplyReview, 0)
	for _, v := range dbf.ReplyReview {
		replies := make([]*model.ComplaintReply, 0)
		for _, v := range v.Replies {
			replies = append(replies, &model.ComplaintReply{
				ID:          &v.Id,
				ComplaintID: &v.ComplaintId,
				Sender: &model.Recipient{
					ID:               &v.Sender.Id,
					SubjectName:      &v.Sender.SubjectName,
					SubjectThumbnail: &v.Sender.SubjectThumbnail,
					SubjectEmail:     &v.Sender.SubjectEmail,
					IsEnterprise:     &v.Sender.IsEnterprise,
				},
				Body:      &v.Body,
				CreatedAt: &v.CreatedAt,
				Read:      &v.Read,
				ReadAt:    &v.ReadAt,
				UpdatedAt: &v.UpdatedAt,
			})
		}
		replyReviews = append(replyReviews, &model.ReplyReview{
			ID:         v.ID,
			FeedbackID: v.FeedbackID,
			Reviewer: &model.User{
				ID:       v.Reviewer.Id,
				UserName: v.Reviewer.Username,
				Person: &model.Person{
					ProfileImg:  v.Reviewer.Person.ProfileImg,
					Email:       v.Reviewer.Person.Email,
					FirstName:   v.Reviewer.Person.FirstName,
					LastName:    v.Reviewer.Person.LastName,
					Genre:       v.Reviewer.Person.Genre,
					Pronoun:     v.Reviewer.Person.Pronoun,
					Age:         v.Reviewer.Person.Age,
					PhoneNumber: v.Reviewer.Person.Phone,
					Address: &model.Address{
						Country:      v.Reviewer.Person.Address.Country,
						CountryState: v.Reviewer.Person.Address.County,
						City:         v.Reviewer.Person.Address.City,
					},
				},
				Status: model.UserStatusOffline,
			},
			Replies: replies,
			Review: &model.Review{
				ID:      v.Review.ReplyReviewID,
				Comment: &v.Review.Comment,
			},
			Color:     v.Color,
			CreatedAt: v.CreatedAt,
		})
	}
	go func() {
		defer func() {
			r.Publisher.Unsubscribe(sub)
			close(ch)
		}()
		ch <- &model.Feedback{
			ID:           dbf.Id,
			ComplaintID:  dbf.ComplaintId,
			EnterpriseID: dbf.EnterpriseId,
			ReplyReview:  replyReviews,
			ReviewedAt:   dbf.ReviewedAt,
			UpdatedAt:    dbf.UpdatedAt,
			IsDone:       dbf.IsDone,
		}
		for {
			select {
			case <-ctx.Done():
				return
			case m := <-in:
				if m.DataType() == "feedback" {
					f, ok := m.Value().(dto.Feedback)
					if ok {
						replyReviews := make([]*model.ReplyReview, 0)
						for _, v := range f.ReplyReview {
							replies := make([]*model.ComplaintReply, 0)
							for _, r := range v.Replies {
								replies = append(replies, &model.ComplaintReply{
									ID:          &r.Id,
									ComplaintID: &r.ComplaintId,
									Sender: &model.Recipient{
										ID:               &r.Sender.Id,
										SubjectName:      &r.Sender.SubjectName,
										SubjectThumbnail: &r.Sender.SubjectThumbnail,
										SubjectEmail:     &r.Sender.SubjectEmail,
										IsEnterprise:     &r.Sender.IsEnterprise,
									},
									Body:      &r.Body,
									CreatedAt: &r.CreatedAt,
									Read:      &r.Read,
									ReadAt:    &r.ReadAt,
									UpdatedAt: &r.UpdatedAt,
								})
							}
							replyReviews = append(replyReviews, &model.ReplyReview{
								ID:         v.ID,
								FeedbackID: v.FeedbackID,
								Reviewer: &model.User{
									ID:       v.Reviewer.Id,
									UserName: v.Reviewer.Username,
									Person: &model.Person{
										ProfileImg:  v.Reviewer.Person.ProfileImg,
										Email:       v.Reviewer.Person.Email,
										FirstName:   v.Reviewer.Person.FirstName,
										LastName:    v.Reviewer.Person.LastName,
										Genre:       v.Reviewer.Person.Genre,
										Pronoun:     v.Reviewer.Person.Pronoun,
										Age:         v.Reviewer.Person.Age,
										PhoneNumber: v.Reviewer.Person.Phone,
										Address: &model.Address{
											Country:      v.Reviewer.Person.Address.Country,
											CountryState: v.Reviewer.Person.Address.County,
											City:         v.Reviewer.Person.Address.City,
										},
									},
									Status: model.UserStatusOffline,
								},
								Replies: replies,
								Review: &model.Review{
									ID:      v.Review.ReplyReviewID,
									Comment: &v.Review.Comment,
								},
								Color:     v.Color,
								CreatedAt: v.CreatedAt,
							})
						}
						ch <- &model.Feedback{
							ID:           f.Id,
							ComplaintID:  f.ComplaintId,
							EnterpriseID: f.EnterpriseId,
							ReplyReview:  replyReviews,
							ReviewedAt:   f.ReviewedAt,
							UpdatedAt:    f.UpdatedAt,
							IsDone:       f.IsDone,
						}
					}
				}
			}
		}
	}()
	return ch, nil
}

// EnterpriseByID is the resolver for the enterpriseById field.
func (r *subscriptionResolver) EnterpriseByID(ctx context.Context, id string, userID string) (<-chan *model.Enterprise, error) {
	query := queries.NewEnterpriseByIdQuery(id)
	dbE, err := query.Execute(ctx)
	if err != nil {
		return nil, err
	}

	dbE.Employees = slices.DeleteFunc(dbE.Employees, func(e *dto.Employee) bool {
		return e.UserID == userID
	})

	pub := application.ApplicationMessagePublisherInstance()
	sub := &application.Subscriber{Id: id, UserId: userID, Send: make(chan application.ApplicationMessage)}
	pub.Subscribe(sub)

	employees := make([]*model.Employee, 0, len(dbE.Employees))
	for _, v := range dbE.Employees {
		emp := &model.Employee{
			ID:           v.ID.String(),
			EnterpriseID: v.EnterpriseID,
			UserID:       v.UserID,
			User: &model.User{
				ID:       v.UserID,
				UserName: v.Email,
				Person: &model.Person{
					ProfileImg:  v.ProfileIMG,
					Email:       v.Email,
					FirstName:   v.FirstName,
					LastName:    v.LastName,
					Genre:       "",
					Pronoun:     "",
					Age:         v.Age,
					PhoneNumber: v.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         v.HiringDate,
			ApprovedHiring:     v.ApprovedHiring,
			ApprovedHiringAt:   v.ApprovedHiringAt,
			EnterprisePosition: v.Position,
		}
		employees = append(employees, emp)
	}
	if dbE.OwnerID != userID {
		userQuery := queries.NewUserByIdQuery(dbE.OwnerID)
		dbOwner, err := userQuery.Execute(ctx)
		if err != nil {
			return nil, err
		}
		employees = append(employees, &model.Employee{
			ID:           dbOwner.Id,
			EnterpriseID: id,
			UserID:       dbOwner.Id,
			User: &model.User{
				ID:       dbOwner.Id,
				UserName: dbOwner.Username,
				Person: &model.Person{
					ProfileImg:  dbOwner.Person.ProfileImg,
					Email:       dbOwner.Person.Email,
					FirstName:   dbOwner.Person.FirstName,
					LastName:    dbOwner.Person.LastName,
					Genre:       dbOwner.Person.Genre,
					Pronoun:     dbOwner.Person.Pronoun,
					Age:         dbOwner.Person.Age,
					PhoneNumber: dbOwner.Person.Phone,
					Address:     &model.Address{},
				},
				Status: model.UserStatusOffline,
			},
			HiringDate:         dbE.FoundationDate,
			ApprovedHiring:     true,
			ApprovedHiringAt:   dbE.FoundationDate,
			EnterprisePosition: "OWNER",
		})
	}
	enterpriseModel := &model.Enterprise{
		ID:          dbE.Id,
		Name:        dbE.Name,
		LogoImg:     dbE.LogoIMG,
		BannerImg:   dbE.BannerIMG,
		Website:     dbE.Website,
		Email:       dbE.Email,
		PhoneNumber: dbE.Phone,
		Address: &model.Address{
			Country:      dbE.Address.Country,
			CountryState: dbE.Address.County,
			City:         dbE.Address.City,
		},
		Industry: &model.Industry{
			ID:   dbE.Industry.ID,
			Name: dbE.Industry.Name,
		},
		FoundationDate: dbE.FoundationDate,
		OwnerID:        dbE.OwnerID,
		Employees:      employees,
	}

	out := make(chan *model.Enterprise)
	go func() {
		defer func() {
			pub.Unsubscribe(sub)
			close(out)
		}()
		out <- enterpriseModel
		for {
			select {
			case <-ctx.Done():
				return
			case m := <-sub.Send:
				switch m.DataType() {
				case "subscriber_connected":
					isOnline := model.UserStatusOnline
					connSub, ok := m.Value().(*application.Subscriber)
					if ok {
						log.Printf("sub connected %v", connSub)
						s := enterpriseModel.Employees
						for _, v := range s {
							switch connSub.Id {
							case v.UserID:
								log.Printf("connected sub.id == employee.userID")
								r.mu.Lock()
								v.User.Status = isOnline
								r.mu.Unlock()
								out <- enterpriseModel
							case v.UserID:
								log.Printf("connected sub.id == employee.userID")
								r.mu.Lock()
								v.User.Status = isOnline
								r.mu.Unlock()
								out <- enterpriseModel
							default:
								log.Printf("sub.id does not match any employee.userID %s", sub.Id)
							}
							switch connSub.UserId {
							case v.UserID:
								log.Printf("connected sub.userid == employee.userID")
								r.mu.Lock()
								v.User.Status = isOnline
								r.mu.Unlock()
								out <- enterpriseModel
							case v.UserID:
								log.Printf("connected sub.userid == employee.userID")
								r.mu.Lock()
								v.User.Status = isOnline
								r.mu.Unlock()
								out <- enterpriseModel
							default:
								log.Printf("sub.userid does not match any employee.userID %s", sub.Id)
							}
						}
					}
				case "subscriber_disconnected":
					isOnline := model.UserStatusOffline
					disConnSub, ok := m.Value().(*application.Subscriber)
					if ok {
						log.Printf("sub disconnected %v", disConnSub)
						s := enterpriseModel.Employees
						for _, v := range s {
							switch disConnSub.Id {
							case v.UserID:
								log.Printf("disconnected sub.id == employee.userID")
								r.mu.Lock()
								v.User.Status = isOnline
								r.mu.Unlock()
								out <- enterpriseModel
							case v.UserID:
								log.Printf("disconnected sub.id == employee.userID")
								r.mu.Lock()
								v.User.Status = isOnline
								r.mu.Unlock()
								out <- enterpriseModel
							default:
								log.Printf("disconnected sub.id does not match any employee.userID %s", sub.Id)
							}
							switch disConnSub.UserId {
							case v.UserID:
								log.Printf("disconnected sub.userid == employee.userID")
								r.mu.Lock()
								v.User.Status = isOnline
								r.mu.Unlock()
								out <- enterpriseModel
							case v.UserID:
								log.Printf("disconnected sub.userid == employee.userID")
								r.mu.Lock()
								v.User.Status = isOnline
								r.mu.Unlock()
								out <- enterpriseModel
							default:
								log.Printf("sub.userid doesnot match any employee.userID %s", sub.Id)
							}
						}
					}
				}
			}
		}
	}()
	return out, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
